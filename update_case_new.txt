        case 'update':
          // ğŸš¨ [REBUILT] é‡æ„çš„ UPDATE é€»è¾‘ - æŒ‰ç”¨æˆ·è¦æ±‚çš„5çº§ä¼˜å…ˆçº§ç»“æ„
          console.log('ğŸ¯ [UPDATE] === UPDATE å†³ç­–æµç¨‹å¼€å§‹ ===');
          console.log('ğŸ” [UPDATE] Processing update action:', {
            entityId: action.entityId,
            title: action.data.title,
            tagId: action.data.tagId,
            calendarId: action.data.calendarId,
            hasDataExternalId: !!action.data.externalId,
            hasOriginalExternalId: !!action.originalData?.externalId
          });

          // ğŸ“Š [PRIORITY 0] æœ€é«˜ä¼˜å…ˆçº§ï¼šç”¨æˆ·æ•°æ®ä¿æŠ¤ - ä¿å­˜æ“ä½œåˆ°æœ¬åœ°æ°¸ä¹…å­˜å‚¨
          try {
            console.log('ğŸ’¾ [PRIORITY 0] Saving user operation to persistent local storage...');
            
            // 1. è·å–å½“å‰æœ¬åœ°äº‹ä»¶æ•°æ®
            const localEvents = this.getLocalEvents();
            const eventIndex = localEvents.findIndex((e: any) => e.id === action.entityId);
            
            if (eventIndex !== -1) {
              // 2. åˆ›å»ºå¤‡ä»½å¹¶æ›´æ–°æœ¬åœ°æ•°æ®
              const backupEvent = {
                ...localEvents[eventIndex],
                lastBackupAt: new Date(),
                backupReason: 'update-operation'
              };
              
              // 3. ç¡®ä¿ç”¨æˆ·ä¿®æ”¹ç«‹å³ä¿å­˜åˆ°æœ¬åœ°
              const updatedEvent = {
                ...localEvents[eventIndex],
                ...action.data,
                updatedAt: new Date(),
                lastLocalEdit: new Date(),
                syncStatus: 'pending-update'
              };
              
              localEvents[eventIndex] = updatedEvent;
              this.saveLocalEvents(localEvents);
              
              console.log('âœ… [PRIORITY 0] User data protected and saved locally');
            }
          } catch (storageError) {
            console.error('âŒ [PRIORITY 0] Failed to save user data locally:', storageError);
            // å³ä½¿æœ¬åœ°ä¿å­˜å¤±è´¥ï¼Œä¹Ÿè¦ç»§ç»­åŒæ­¥ï¼Œä½†æ·»åŠ å†²çªæ ‡è®°
            if (!action.data.title.includes('âš ï¸åŒæ­¥å†²çª')) {
              action.data.title = 'âš ï¸åŒæ­¥å†²çª - ' + action.data.title;
              console.log('ğŸš¨ [PRIORITY 0] Added conflict marker to title');
            }
          }

          // ğŸ” [PRIORITY 1] æœ€é«˜ä¼˜å…ˆçº§ï¼šæ£€æŸ¥äº‹ä»¶åŸºç¡€çŠ¶æ€
          console.log('ğŸ” [PRIORITY 1] === äº‹ä»¶åŸºç¡€çŠ¶æ€æ£€æŸ¥ ===');
          
          // 1ï¸âƒ£ ç¼–è¾‘é”å®šæ£€æŸ¥ - é˜²æ­¢è¿œç¨‹è¦†ç›–æ­£åœ¨ç¼–è¾‘çš„äº‹ä»¶
          if (this.isEditLocked(action.entityId)) {
            console.log('ğŸ”’ [PRIORITY 1] Event is edit-locked, skipping remote sync to protect local edits');
            return true; // æˆåŠŸï¼ˆæœ¬åœ°å·²æ›´æ–°ï¼‰ï¼Œä½†è·³è¿‡è¿œç¨‹åŒæ­¥
          }
          
          // ä¸ºå½“å‰æ›´æ–°æ“ä½œè®¾ç½®ç¼–è¾‘é”å®š
          this.setEditLock(action.entityId, 15000); // 15ç§’é”å®šæœŸ
          
          // 2ï¸âƒ£ ExternalId æ£€æŸ¥ - å†³å®šæ˜¯ UPDATE è¿˜æ˜¯ CREATE
          let cleanExternalId = action.data.externalId || action.originalData?.externalId;
          
          if (cleanExternalId && cleanExternalId.startsWith('outlook-')) {
            cleanExternalId = cleanExternalId.replace('outlook-', '');
          }
          
          console.log('ğŸ” [PRIORITY 1] ExternalId analysis:', {
            dataExternalId: action.data.externalId,
            originalExternalId: action.originalData?.externalId,
            finalCleanExternalId: cleanExternalId,
            decision: cleanExternalId ? 'PROCEED_WITH_UPDATE' : 'CONVERT_TO_CREATE'
          });
          
          // ğŸ”„ å¦‚æœæ²¡æœ‰ externalIdï¼Œè½¬ä¸º CREATE æ“ä½œ
          if (!cleanExternalId) {
            console.log('ğŸ”„ [PRIORITY 1] No externalId found - Converting UPDATE â†’ CREATE (first-time sync)');
            
            // æ‰§è¡Œ CREATE é€»è¾‘ï¼ˆå¤ç”¨ç°æœ‰çš„ create åˆ†æ”¯é€»è¾‘ï¼‰
            let targetCalendarId = action.data.calendarId;
            if (!targetCalendarId && action.data.tagId) {
              targetCalendarId = this.getCalendarIdForTag(action.data.tagId);
            }
            if (!targetCalendarId) {
              targetCalendarId = this.microsoftService.getSelectedCalendarId();
            }
            
            const originalCreateTime = this.extractOriginalCreateTime(action.data.description || '');
            const createDescription = this.processEventDescription(
              action.data.description || '',
              'remarkable',
              'create',
              { ...action.data, preserveOriginalCreateTime: originalCreateTime }
            );
            
            const eventData = {
              subject: action.data.title,
              body: { contentType: 'text', content: createDescription },
              start: { dateTime: this.safeFormatDateTime(action.data.startTime), timeZone: 'Asia/Shanghai' },
              end: { dateTime: this.safeFormatDateTime(action.data.endTime), timeZone: 'Asia/Shanghai' },
              location: action.data.location ? { displayName: action.data.location } : undefined,
              isAllDay: action.data.isAllDay || false
            };
            
            const newEventId = await this.microsoftService.syncEventToCalendar(eventData, targetCalendarId);
            
            if (newEventId) {
              this.updateLocalEventExternalId(action.entityId, newEventId, createDescription);
              this.updateLocalEventCalendarId(action.entityId, targetCalendarId);
              this.clearEditLock(action.entityId);
              console.log('âœ… [PRIORITY 1] UPDATE â†’ CREATE completed successfully');
              
              // ğŸ“ çŠ¶æ€æ åé¦ˆ
              window.dispatchEvent(new CustomEvent('sync-status-update', {
                detail: { message: `âœ… å·²åˆ›å»º1ä¸ªäº‹ä»¶åˆ°Outlook: ${targetCalendarId}` }
              }));
              return true;
            } else {
              this.clearEditLock(action.entityId);
              console.error('âŒ [PRIORITY 1] UPDATE â†’ CREATE failed');
              return false;
            }
          }

          // ğŸ·ï¸ [PRIORITY 2] é«˜ä¼˜å…ˆçº§ï¼šæ ‡ç­¾æ—¥å†æ˜ å°„æ£€æŸ¥
          console.log('ğŸ·ï¸ [PRIORITY 2] === æ ‡ç­¾æ—¥å†æ˜ å°„æ£€æŸ¥ ===');
          
          let currentCalendarId = action.data.calendarId;
          let needsCalendarMigration = false;
          let targetCalendarId = currentCalendarId;
          
          if (action.data.tagId) {
            console.log('ğŸ” [PRIORITY 2] Checking tag mapping for tagId:', action.data.tagId);
            const mappedCalendarId = this.getCalendarIdForTag(action.data.tagId);
            
            console.log('ğŸ” [PRIORITY 2] Calendar mapping result:', {
              currentCalendar: currentCalendarId || 'None',
              mappedCalendar: mappedCalendarId || 'None',
              needsMigration: !!(mappedCalendarId && mappedCalendarId !== currentCalendarId)
            });
            
            // æ£€æŸ¥æ˜¯å¦éœ€è¦è·¨æ—¥å†è¿ç§»
            if (mappedCalendarId && mappedCalendarId !== currentCalendarId) {
              needsCalendarMigration = true;
              targetCalendarId = mappedCalendarId;
              
              console.log('ğŸ”„ [PRIORITY 2] Calendar migration required:', {
                from: currentCalendarId || 'Default',
                to: mappedCalendarId,
                eventTitle: action.data.title
              });
              
              try {
                // åˆ é™¤åŸæ—¥å†ä¸­çš„äº‹ä»¶
                console.log('ğŸ—‘ï¸ [PRIORITY 2] Deleting from original calendar...');
                await this.microsoftService.deleteEvent(cleanExternalId);
                console.log('âœ… [PRIORITY 2] Successfully deleted from original calendar');
                
                // åœ¨æ–°æ—¥å†ä¸­åˆ›å»ºäº‹ä»¶ï¼ˆç›¸å½“äºè¿ç§»ï¼‰
                const migrateDescription = this.processEventDescription(
                  action.data.description || '',
                  'remarkable',
                  'update',
                  action.data
                );
                
                const migrateEventData = {
                  subject: action.data.title,
                  body: { contentType: 'text', content: migrateDescription },
                  start: { dateTime: this.safeFormatDateTime(action.data.startTime), timeZone: 'Asia/Shanghai' },
                  end: { dateTime: this.safeFormatDateTime(action.data.endTime), timeZone: 'Asia/Shanghai' },
                  location: action.data.location ? { displayName: action.data.location } : undefined,
                  isAllDay: action.data.isAllDay || false
                };
                
                console.log('âœ¨ [PRIORITY 2] Creating in new calendar:', targetCalendarId);
                const newEventId = await this.microsoftService.syncEventToCalendar(migrateEventData, targetCalendarId);
                
                if (newEventId) {
                  this.updateLocalEventExternalId(action.entityId, newEventId, migrateDescription);
                  this.updateLocalEventCalendarId(action.entityId, targetCalendarId);
                  this.clearEditLock(action.entityId);
                  console.log('âœ… [PRIORITY 2] Calendar migration completed successfully');
                  
                  // ğŸ“ çŠ¶æ€æ åé¦ˆ
                  window.dispatchEvent(new CustomEvent('sync-status-update', {
                    detail: { message: `ğŸ”„ å·²è¿ç§»1ä¸ªäº‹ä»¶åˆ°æ—¥å†: ${targetCalendarId}` }
                  }));
                  return true;
                }
              } catch (migrationError) {
                console.error('âŒ [PRIORITY 2] Calendar migration failed:', migrationError);
                // è¿ç§»å¤±è´¥ï¼Œç»§ç»­æ‰§è¡Œæ™®é€šæ›´æ–°
                needsCalendarMigration = false;
              }
            }
          }

          // ğŸ“ [PRIORITY 3] ä¸­ç­‰ä¼˜å…ˆçº§ï¼šå­—æ®µæ›´æ–°å¤„ç†
          console.log('ğŸ“ [PRIORITY 3] === å­—æ®µæ›´æ–°å¤„ç† ===');
          
          // 3ï¸âƒ£ æ„å»ºæ›´æ–°æ•°æ®
          const updateData: any = {};
          
          // ğŸ“ æ–‡æœ¬å­—æ®µå¤„ç†
          console.log('ğŸ“ [PRIORITY 3] Processing text fields...');
          if (action.data.title) {
            updateData.subject = action.data.title;
            console.log('ğŸ“ Title updated:', action.data.title);
          }
          
          // æè¿°å¤„ç†ï¼šæ·»åŠ åŒæ­¥å¤‡æ³¨ç®¡ç†
          if (action.data.description !== undefined) {
            const updateDescription = this.processEventDescription(
              action.data.description || '',
              'remarkable',
              'update',
              action.data
            );
            updateData.body = { contentType: 'text', content: updateDescription };
            console.log('ğŸ“ Description updated with sync notes');
          }
          
          if (action.data.location !== undefined) {
            if (action.data.location) {
              updateData.location = { displayName: action.data.location };
              console.log('ğŸ“ Location updated:', action.data.location);
            } else {
              updateData.location = null; // æ¸…ç©ºä½ç½®
              console.log('ğŸ“ Location cleared');
            }
          }
          
          // â° æ—¶é—´å­—æ®µå¤„ç†
          console.log('â° [PRIORITY 3] Processing time fields...');
          if (action.data.startTime && action.data.endTime) {
            try {
              const startDateTime = this.safeFormatDateTime(action.data.startTime);
              const endDateTime = this.safeFormatDateTime(action.data.endTime);
              
              // æ—¶é—´éªŒè¯
              const startDate = new Date(startDateTime);
              const endDate = new Date(endDateTime);
              
              if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                throw new Error('Invalid date values');
              }
              
              if (endDate <= startDate) {
                throw new Error('End time must be after start time');
              }
              
              updateData.start = { dateTime: startDateTime, timeZone: 'Asia/Shanghai' };
              updateData.end = { dateTime: endDateTime, timeZone: 'Asia/Shanghai' };
              
              console.log('â° Time fields validated and updated:', {
                start: startDateTime,
                end: endDateTime
              });
              
            } catch (timeError) {
              console.error('âŒ [PRIORITY 3] Time validation failed:', timeError);
              this.clearEditLock(action.entityId);
              throw new Error(`Time update failed: ${timeError instanceof Error ? timeError.message : 'Invalid time data'}`);
            }
          }
          
          // ğŸ·ï¸ å…ƒæ•°æ®å­—æ®µå¤„ç†
          if (typeof action.data.isAllDay === 'boolean') {
            updateData.isAllDay = action.data.isAllDay;
            console.log('ğŸ·ï¸ All-day flag updated:', action.data.isAllDay);
          }

          // ğŸ¯ [PRIORITY 4] æ ‡å‡†ä¼˜å…ˆçº§ï¼šæ‰§è¡Œæ›´æ–°æ“ä½œ
          console.log('ğŸ¯ [PRIORITY 4] === æ‰§è¡Œæ›´æ–°æ“ä½œ ===');
          console.log('ğŸ¯ Sending update to Outlook:', {
            externalId: cleanExternalId,
            fieldsToUpdate: Object.keys(updateData),
            updateData: JSON.stringify(updateData, null, 2)
          });
          
          try {
            const updateResult = await this.microsoftService.updateEvent(cleanExternalId, updateData);
            
            if (updateResult) {
              this.clearEditLock(action.entityId);
              console.log('âœ… [PRIORITY 4] Update operation completed successfully');
              
              // ğŸ“ çŠ¶æ€æ åé¦ˆ
              window.dispatchEvent(new CustomEvent('sync-status-update', {
                detail: { message: `âœ… å·²æ›´æ–°1ä¸ªäº‹ä»¶åˆ°Outlook: ${targetCalendarId || 'Default'}` }
              }));
              return true;
            }
          } catch (updateError) {
            console.error('âŒ [PRIORITY 4] Update operation failed:', updateError);
            
            // ğŸ”§ é”™è¯¯å¤„ç†ï¼šäº‹ä»¶ä¸å­˜åœ¨æ—¶è½¬ä¸º CREATE
            if (updateError instanceof Error && updateError.message.includes('Event not found')) {
              console.log('ğŸ”„ [PRIORITY 4] Event not found - Converting to CREATE operation');
              
              try {
                let createCalendarId = targetCalendarId || this.microsoftService.getSelectedCalendarId();
                
                const recreateDescription = this.processEventDescription(
                  action.data.description || '',
                  'remarkable',
                  'create',
                  action.data
                );
                
                const recreateEventData = {
                  subject: action.data.title,
                  body: { contentType: 'text', content: recreateDescription },
                  start: { dateTime: this.safeFormatDateTime(action.data.startTime), timeZone: 'Asia/Shanghai' },
                  end: { dateTime: this.safeFormatDateTime(action.data.endTime), timeZone: 'Asia/Shanghai' },
                  location: action.data.location ? { displayName: action.data.location } : undefined,
                  isAllDay: action.data.isAllDay || false
                };
                
                const recreatedEventId = await this.microsoftService.syncEventToCalendar(recreateEventData, createCalendarId);
                
                if (recreatedEventId) {
                  this.updateLocalEventExternalId(action.entityId, recreatedEventId, recreateDescription);
                  this.updateLocalEventCalendarId(action.entityId, createCalendarId);
                  this.clearEditLock(action.entityId);
                  console.log('âœ… [PRIORITY 4] Successfully recreated event after not found error');
                  
                  // ğŸ“ çŠ¶æ€æ åé¦ˆ
                  window.dispatchEvent(new CustomEvent('sync-status-update', {
                    detail: { message: `ğŸ”„ å·²é‡æ–°åˆ›å»º1ä¸ªäº‹ä»¶: ${createCalendarId}` }
                  }));
                  return true;
                }
              } catch (recreateError) {
                console.error('âŒ [PRIORITY 4] Failed to recreate event:', recreateError);
              }
            }
            
            // ğŸ”§ å°è¯•æœ€å°æ›´æ–°ï¼ˆä»…æ ‡é¢˜å’Œæè¿°ï¼‰
            console.log('ğŸ”§ [PRIORITY 4] Attempting minimal update (title + description only)...');
            try {
              const minimalUpdate = {
                subject: action.data.title,
                body: { 
                  contentType: 'text', 
                  content: action.data.description || 'ğŸ“± ç”± ReMarkable æ›´æ–°'
                }
              };
              
              const minimalResult = await this.microsoftService.updateEvent(cleanExternalId, minimalUpdate);
              
              if (minimalResult) {
                this.clearEditLock(action.entityId);
                console.log('âœ… [PRIORITY 4] Minimal update succeeded');
                
                // ğŸ“ çŠ¶æ€æ åé¦ˆ
                window.dispatchEvent(new CustomEvent('sync-status-update', {
                  detail: { message: `âš ï¸ å·²éƒ¨åˆ†æ›´æ–°1ä¸ªäº‹ä»¶ (ä»…æ ‡é¢˜å’Œæè¿°)` }
                }));
                return true;
              }
            } catch (minimalError) {
              console.error('âŒ [PRIORITY 4] Even minimal update failed:', minimalError);
            }
            
            // ğŸš¨ æœ€ç»ˆé”™è¯¯å¤„ç†ï¼šä¿æŒæœ¬åœ°æ•°æ®ï¼Œæ ‡è®°åŒæ­¥å†²çª
            this.clearEditLock(action.entityId);
            console.error('ğŸš¨ [PRIORITY 4] All update attempts failed, marking as sync conflict');
            
            // æ›´æ–°æœ¬åœ°äº‹ä»¶ï¼Œæ·»åŠ åŒæ­¥å†²çªæ ‡è®°
            const localEvents = this.getLocalEvents();
            const conflictEventIndex = localEvents.findIndex((e: any) => e.id === action.entityId);
            if (conflictEventIndex !== -1) {
              if (!localEvents[conflictEventIndex].title.includes('âš ï¸åŒæ­¥å†²çª')) {
                localEvents[conflictEventIndex].title = 'âš ï¸åŒæ­¥å†²çª - ' + localEvents[conflictEventIndex].title;
                localEvents[conflictEventIndex].syncStatus = 'conflict';
                localEvents[conflictEventIndex].lastSyncError = updateError instanceof Error ? updateError.message : 'Unknown error';
                this.saveLocalEvents(localEvents);
                
                // ğŸ“ çŠ¶æ€æ åé¦ˆ
                window.dispatchEvent(new CustomEvent('sync-status-update', {
                  detail: { message: `âš ï¸ åŒæ­¥å†²çª: å·²ä¿æŠ¤æœ¬åœ°æ•°æ®` }
                }));
              }
            }
            
            throw updateError;
          }

          // ğŸ“Š [PRIORITY 5] ä½ä¼˜å…ˆçº§ï¼šåç»­å¤„ç†ï¼ˆå·²åœ¨ä¸Šé¢çš„æˆåŠŸåˆ†æ”¯ä¸­å¤„ç†ï¼‰
          console.log('ğŸ“Š [PRIORITY 5] Update process completed');
          break;