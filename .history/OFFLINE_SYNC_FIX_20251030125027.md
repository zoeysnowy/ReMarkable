# 离线事件同步问题修复方案（已实现）

## ✅ 已实现的改进

### 1. 网络状态监听（最重要）

**实现内容：**
- ✅ 监听 `window.addEventListener('online')` - 网络恢复时立即触发同步
- ✅ 监听 `window.addEventListener('offline')` - 网络断开时显示通知
- ✅ 使用 `navigator.onLine` 检查网络状态
- ✅ 网络恢复后1秒延迟同步，让网络稳定

**代码位置：** `ActionBasedSyncManager.setupNetworkListeners()`

### 2. 无限重试机制

**实现内容：**
- ✅ 移除了3次重试限制
- ✅ 未同步的action会在每次轮询时自动重试
- ✅ 只要在actionQueue中且未同步，就会持续尝试
- ✅ 按失败次数排序，优先同步新创建的事件

**代码位置：** `ActionBasedSyncManager.syncSingleAction()` 和 `syncPendingLocalActions()`

### 3. 用户通知机制

**实现内容：**
- ✅ 每失败3次通知用户一次（避免频繁打扰）
- ✅ 通知包含：事件标题、重试次数、失败原因
- ✅ 通过自定义事件 `syncFailure` 通知UI层
- ✅ 网络状态变化时通知用户

**事件详情：**
```typescript
window.addEventListener('syncFailure', (event) => {
  const { eventTitle, retryCount, error, timestamp } = event.detail;
  // 显示通知给用户
});

window.addEventListener('networkStatusChanged', (event) => {
  const { status, message } = event.detail;
  // 显示网络状态通知
});
```

### 4. 改进的网络检查

**实现内容：**
- ✅ `recordLocalAction` 中检查 `navigator.onLine`
- ✅ 离线时不尝试同步，直接排队
- ✅ 详细的日志输出便于调试

## 工作流程

```
1. 用户停止Timer
   ↓
2. App.tsx: handleTimerStop()
   → 创建本地事件 (syncStatus: 'pending')
   → 保存到 localStorage
   ↓
3. 延迟5秒后调用 syncManager.recordLocalAction()
   ↓
4. ActionBasedSyncManager: recordLocalAction()
   → 创建 SyncAction
   → 保存到 actionQueue (localStorage)
   → 检查 isRunning && isSignedIn()
   ↓
5. 如果条件满足：setTimeout(() => syncSingleAction(action), 0)
   如果条件不满足：⚠️ 等待下次定时同步（20秒后）
   ↓
6. syncSingleAction()
   → 尝试同步到远程
   → 如果失败：retryCount++
   → 如果 retryCount >= 3：❌ 不再重试
   ↓
7. 定时同步 (每20秒)
   → performSync()
   → syncPendingLocalActions()
   → 重试未同步的 actions
```

**问题点：**
- ❌ 步骤5：网络断开时条件可能满足，但同步会失败
- ❌ 步骤6：3次重试用完后不再尝试
- ❌ 没有在网络恢复时立即重试

## 修复方案

### 方案1：添加网络状态监听（推荐）✅

**优点：**
- 网络恢复时立即同步，响应迅速
- 不依赖定时器，更可靠
- 实现简单

**实现：**

```typescript
// 在 ActionBasedSyncManager.ts 的 constructor 或 start() 中添加

constructor(microsoftService: any) {
  // ... 现有代码 ...
  
  // 🔧 [NEW] 监听网络状态变化
  this.setupNetworkListeners();
}

private setupNetworkListeners() {
  // 监听网络恢复
  window.addEventListener('online', () => {
    console.log('🌐 [Network] Network is back online, triggering sync...');
    
    // 等待1秒让网络稳定
    setTimeout(() => {
      if (this.isRunning && !this.syncInProgress) {
        console.log('🔄 [Network] Executing sync after network recovery');
        this.performSync();
      }
    }, 1000);
  });
  
  // 监听网络断开（可选，用于日志）
  window.addEventListener('offline', () => {
    console.log('📴 [Network] Network is offline, sync will be queued');
  });
}

public stop() {
  this.isRunning = false;
  if (this.syncInterval) {
    clearInterval(this.syncInterval);
    this.syncInterval = null;
  }
  
  // 🔧 [NEW] 清理网络监听器
  // 注意：如果需要清理，应该保存监听函数的引用
}
```

### 方案2：增加重试次数和智能退避

**优点：**
- 长时间断网也能保持重试
- 指数退避避免频繁失败

**实现：**

```typescript
// 修改 syncSingleAction 方法

private async syncSingleAction(action: SyncAction) {
  // ... 现有代码 ...
  
  // 🔧 [MODIFIED] 增加最大重试次数到 10 次，并添加智能判断
  const MAX_RETRIES = 10;
  
  // 🔧 [NEW] 如果是网络错误，不计入重试次数限制
  if (action.synchronized || action.retryCount >= MAX_RETRIES) {
    // 检查是否是网络错误
    if (action.lastError && this.isNetworkError(action.lastError)) {
      console.log('⚠️ [SYNC] Max retries reached but it\'s a network error, will retry on next sync');
      // 不返回，继续尝试（由定时同步触发）
    } else {
      console.log('🔍 [SYNC SINGLE ACTION] Skipping action - already synchronized or max retries reached');
      return;
    }
  }

  try {
    // ... 同步逻辑 ...
  } catch (error) {
    console.error('❌ [SYNC SINGLE ACTION] Failed to sync action:', error);
    
    // 🔧 [NEW] 记录错误类型
    action.lastError = error instanceof Error ? error.message : 'Unknown error';
    action.retryCount++;
    
    // 🔧 [NEW] 指数退避
    const backoffDelay = Math.min(1000 * Math.pow(2, action.retryCount), 30000);
    console.log(`⏰ [SYNC] Will retry after ${backoffDelay}ms`);
    
    this.saveActionQueue();
  }
}

// 🔧 [NEW] 判断是否是网络错误
private isNetworkError(errorMessage: string): boolean {
  const networkErrorPatterns = [
    'network',
    'fetch',
    'timeout',
    'connection',
    'offline',
    'ENOTFOUND',
    'ECONNREFUSED'
  ];
  
  return networkErrorPatterns.some(pattern => 
    errorMessage.toLowerCase().includes(pattern)
  );
}
```

### 方案3：改进 recordLocalAction 的网络检查

**优点：**
- 避免在网络断开时浪费重试次数
- 更早发现网络问题

**实现：**

```typescript
public recordLocalAction(type: 'create' | 'update' | 'delete', entityType: 'event' | 'task', entityId: string, data?: any, oldData?: any) {
  // ... 创建 action 代码 ...
  
  this.actionQueue.push(action);
  this.saveActionQueue();
  
  // 🔧 [MODIFIED] 添加网络状态检查
  const isOnline = navigator.onLine;
  
  console.log('🔍 [RECORD LOCAL ACTION] Sync conditions:', {
    isRunning: this.isRunning,
    isSignedIn: this.microsoftService?.isSignedIn(),
    isOnline: isOnline,  // 🔧 [NEW]
    willTriggerSync: this.isRunning && this.microsoftService?.isSignedIn() && isOnline
  });
  
  if (this.isRunning && this.microsoftService.isSignedIn() && isOnline) {
    console.log('🔍 [RECORD LOCAL ACTION] Scheduling async syncSingleAction...');
    setTimeout(() => {
      this.syncSingleAction(action);
    }, 0);
  } else {
    if (!isOnline) {
      console.log('📴 [RECORD LOCAL ACTION] Network is offline, action will be synced when online');
    } else {
      console.log('⚠️ [RECORD LOCAL ACTION] Sync conditions not met, action will be queued for later sync');
    }
  }
}
```

## 推荐的完整解决方案

结合以上三个方案：

1. ✅ **添加网络状态监听**（方案1）- 最重要
2. ✅ **增加重试次数和智能判断**（方案2）
3. ✅ **改进网络状态检查**（方案3）

### 额外优化

```typescript
// 🔧 [NEW] 在 SyncAction 接口中添加字段
interface SyncAction {
  // ... 现有字段 ...
  lastError?: string;  // 记录最后一次错误
  lastAttemptTime?: Date;  // 记录最后一次尝试时间
}

// 🔧 [NEW] 在 performSync 中优先处理失败的 actions
private async performSync() {
  // ... 现有代码 ...
  
  // 🔧 优先同步失败次数少的 actions
  await this.syncPendingLocalActions();
  
  // ... 其他同步代码 ...
}

private async syncPendingLocalActions() {
  const pendingLocalActions = this.actionQueue.filter(
    action => action.source === 'local' && !action.synchronized
  );
  
  // 🔧 [NEW] 按重试次数排序，优先处理失败次数少的
  pendingLocalActions.sort((a, b) => 
    (a.retryCount || 0) - (b.retryCount || 0)
  );
  
  console.log('📊 [Sync] Pending local actions:', {
    total: pendingLocalActions.length,
    byRetryCount: pendingLocalActions.reduce((acc, action) => {
      const count = action.retryCount || 0;
      acc[count] = (acc[count] || 0) + 1;
      return acc;
    }, {} as Record<number, number>)
  });

  for (const action of pendingLocalActions) {
    await this.syncSingleAction(action);
  }
}
```

## 测试方案

### 测试步骤

1. **断网测试**
   ```
   1. 断开网络连接
   2. 启动Timer并停止，创建事件
   3. 检查localStorage中的actionQueue是否包含该action
   4. 恢复网络连接
   5. 观察控制台日志，应该看到：
      - "🌐 [Network] Network is back online"
      - "🔄 [Network] Executing sync after network recovery"
      - 事件同步成功
   ```

2. **长时间断网测试**
   ```
   1. 断开网络连接
   2. 创建多个Timer事件
   3. 保持断网超过60秒
   4. 恢复网络
   5. 验证所有事件都能同步成功
   ```

3. **刷新页面测试**
   ```
   1. 断网状态下创建事件
   2. 刷新页面
   3. 恢复网络
   4. 验证事件能自动同步
   ```

### 预期日志

```
// 断网时
📴 [Network] Network is offline, sync will be queued
🔍 [RECORD LOCAL ACTION] Network is offline, action will be synced when online

// 联网后
🌐 [Network] Network is back online, triggering sync...
🔄 [Network] Executing sync after network recovery
🔄 [performSync] Starting sync cycle...
📊 [Sync] Pending local actions: {"total": 3, "byRetryCount": {"0": 3}}
✅ [SYNC SINGLE ACTION] Action completed successfully
```

## 代码修改位置

需要修改的文件：
- `src/services/ActionBasedSyncManager.ts`

需要添加的方法：
1. `setupNetworkListeners()` - 设置网络监听
2. `isNetworkError()` - 判断网络错误
3. 修改 `syncSingleAction()` - 增加重试次数和智能判断
4. 修改 `recordLocalAction()` - 添加网络检查
5. 修改 `syncPendingLocalActions()` - 优先处理失败次数少的

## 兼容性说明

- `navigator.onLine` - 所有现代浏览器支持
- `window.addEventListener('online/offline')` - IE9+ 支持
- 对现有功能无影响，纯新增功能

## 总结

通过添加网络状态监听和改进重试机制，可以确保：
1. ✅ 断网时创建的事件会被正确保存到队列
2. ✅ 联网后立即自动同步（1秒延迟）
3. ✅ 长时间断网也能保持重试
4. ✅ 刷新页面后仍能继续同步

这个修复方案不会破坏现有功能，只是增加了更可靠的同步保障。
