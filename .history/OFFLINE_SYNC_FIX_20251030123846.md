# 离线事件同步问题修复方案

## 问题分析

### 发现的问题

在断网状态下创建的本地事件（如Timer事件），在联网后**没有及时同步到远程Outlook日历**。

### 根本原因

通过检查代码，发现以下几个问题：

1. **❌ 缺少网络状态监听**
   - 代码中没有监听 `window.addEventListener('online')` 事件
   - 网络恢复后不会主动触发同步，只能等待定时器（20秒）

2. **⚠️ 重试次数限制过严格**
   - `syncSingleAction` 中设置了 `retryCount >= 3` 的限制
   - 如果网络长时间断开（>60秒），3次重试会很快用完
   - 之后即使网络恢复也不会再尝试同步

3. **⏱️ 依赖定时同步**
   - 主要依赖20秒的 `performSync()` 定时器来重试失败的actions
   - 如果用户在断网期间创建事件后立即关闭应用，定时器来不及运行

4. **📊 同步条件检查不完整**
   - `recordLocalAction` 中只检查 `isSignedIn()`，没有检查实际网络连接
   - 即使 `isSignedIn()` 返回true，网络可能已断开

## 当前同步流程

```
1. 用户停止Timer
   ↓
2. App.tsx: handleTimerStop()
   → 创建本地事件 (syncStatus: 'pending')
   → 保存到 localStorage
   ↓
3. 延迟5秒后调用 syncManager.recordLocalAction()
   ↓
4. ActionBasedSyncManager: recordLocalAction()
   → 创建 SyncAction
   → 保存到 actionQueue (localStorage)
   → 检查 isRunning && isSignedIn()
   ↓
5. 如果条件满足：setTimeout(() => syncSingleAction(action), 0)
   如果条件不满足：⚠️ 等待下次定时同步（20秒后）
   ↓
6. syncSingleAction()
   → 尝试同步到远程
   → 如果失败：retryCount++
   → 如果 retryCount >= 3：❌ 不再重试
   ↓
7. 定时同步 (每20秒)
   → performSync()
   → syncPendingLocalActions()
   → 重试未同步的 actions
```

**问题点：**
- ❌ 步骤5：网络断开时条件可能满足，但同步会失败
- ❌ 步骤6：3次重试用完后不再尝试
- ❌ 没有在网络恢复时立即重试

## 修复方案

### 方案1：添加网络状态监听（推荐）✅

**优点：**
- 网络恢复时立即同步，响应迅速
- 不依赖定时器，更可靠
- 实现简单

**实现：**

```typescript
// 在 ActionBasedSyncManager.ts 的 constructor 或 start() 中添加

constructor(microsoftService: any) {
  // ... 现有代码 ...
  
  // 🔧 [NEW] 监听网络状态变化
  this.setupNetworkListeners();
}

private setupNetworkListeners() {
  // 监听网络恢复
  window.addEventListener('online', () => {
    console.log('🌐 [Network] Network is back online, triggering sync...');
    
    // 等待1秒让网络稳定
    setTimeout(() => {
      if (this.isRunning && !this.syncInProgress) {
        console.log('🔄 [Network] Executing sync after network recovery');
        this.performSync();
      }
    }, 1000);
  });
  
  // 监听网络断开（可选，用于日志）
  window.addEventListener('offline', () => {
    console.log('📴 [Network] Network is offline, sync will be queued');
  });
}

public stop() {
  this.isRunning = false;
  if (this.syncInterval) {
    clearInterval(this.syncInterval);
    this.syncInterval = null;
  }
  
  // 🔧 [NEW] 清理网络监听器
  // 注意：如果需要清理，应该保存监听函数的引用
}
```

### 方案2：增加重试次数和智能退避

**优点：**
- 长时间断网也能保持重试
- 指数退避避免频繁失败

**实现：**

```typescript
// 修改 syncSingleAction 方法

private async syncSingleAction(action: SyncAction) {
  // ... 现有代码 ...
  
  // 🔧 [MODIFIED] 增加最大重试次数到 10 次，并添加智能判断
  const MAX_RETRIES = 10;
  
  // 🔧 [NEW] 如果是网络错误，不计入重试次数限制
  if (action.synchronized || action.retryCount >= MAX_RETRIES) {
    // 检查是否是网络错误
    if (action.lastError && this.isNetworkError(action.lastError)) {
      console.log('⚠️ [SYNC] Max retries reached but it\'s a network error, will retry on next sync');
      // 不返回，继续尝试（由定时同步触发）
    } else {
      console.log('🔍 [SYNC SINGLE ACTION] Skipping action - already synchronized or max retries reached');
      return;
    }
  }

  try {
    // ... 同步逻辑 ...
  } catch (error) {
    console.error('❌ [SYNC SINGLE ACTION] Failed to sync action:', error);
    
    // 🔧 [NEW] 记录错误类型
    action.lastError = error instanceof Error ? error.message : 'Unknown error';
    action.retryCount++;
    
    // 🔧 [NEW] 指数退避
    const backoffDelay = Math.min(1000 * Math.pow(2, action.retryCount), 30000);
    console.log(`⏰ [SYNC] Will retry after ${backoffDelay}ms`);
    
    this.saveActionQueue();
  }
}

// 🔧 [NEW] 判断是否是网络错误
private isNetworkError(errorMessage: string): boolean {
  const networkErrorPatterns = [
    'network',
    'fetch',
    'timeout',
    'connection',
    'offline',
    'ENOTFOUND',
    'ECONNREFUSED'
  ];
  
  return networkErrorPatterns.some(pattern => 
    errorMessage.toLowerCase().includes(pattern)
  );
}
```

### 方案3：改进 recordLocalAction 的网络检查

**优点：**
- 避免在网络断开时浪费重试次数
- 更早发现网络问题

**实现：**

```typescript
public recordLocalAction(type: 'create' | 'update' | 'delete', entityType: 'event' | 'task', entityId: string, data?: any, oldData?: any) {
  // ... 创建 action 代码 ...
  
  this.actionQueue.push(action);
  this.saveActionQueue();
  
  // 🔧 [MODIFIED] 添加网络状态检查
  const isOnline = navigator.onLine;
  
  console.log('🔍 [RECORD LOCAL ACTION] Sync conditions:', {
    isRunning: this.isRunning,
    isSignedIn: this.microsoftService?.isSignedIn(),
    isOnline: isOnline,  // 🔧 [NEW]
    willTriggerSync: this.isRunning && this.microsoftService?.isSignedIn() && isOnline
  });
  
  if (this.isRunning && this.microsoftService.isSignedIn() && isOnline) {
    console.log('🔍 [RECORD LOCAL ACTION] Scheduling async syncSingleAction...');
    setTimeout(() => {
      this.syncSingleAction(action);
    }, 0);
  } else {
    if (!isOnline) {
      console.log('📴 [RECORD LOCAL ACTION] Network is offline, action will be synced when online');
    } else {
      console.log('⚠️ [RECORD LOCAL ACTION] Sync conditions not met, action will be queued for later sync');
    }
  }
}
```

## 推荐的完整解决方案

结合以上三个方案：

1. ✅ **添加网络状态监听**（方案1）- 最重要
2. ✅ **增加重试次数和智能判断**（方案2）
3. ✅ **改进网络状态检查**（方案3）

### 额外优化

```typescript
// 🔧 [NEW] 在 SyncAction 接口中添加字段
interface SyncAction {
  // ... 现有字段 ...
  lastError?: string;  // 记录最后一次错误
  lastAttemptTime?: Date;  // 记录最后一次尝试时间
}

// 🔧 [NEW] 在 performSync 中优先处理失败的 actions
private async performSync() {
  // ... 现有代码 ...
  
  // 🔧 优先同步失败次数少的 actions
  await this.syncPendingLocalActions();
  
  // ... 其他同步代码 ...
}

private async syncPendingLocalActions() {
  const pendingLocalActions = this.actionQueue.filter(
    action => action.source === 'local' && !action.synchronized
  );
  
  // 🔧 [NEW] 按重试次数排序，优先处理失败次数少的
  pendingLocalActions.sort((a, b) => 
    (a.retryCount || 0) - (b.retryCount || 0)
  );
  
  console.log('📊 [Sync] Pending local actions:', {
    total: pendingLocalActions.length,
    byRetryCount: pendingLocalActions.reduce((acc, action) => {
      const count = action.retryCount || 0;
      acc[count] = (acc[count] || 0) + 1;
      return acc;
    }, {} as Record<number, number>)
  });

  for (const action of pendingLocalActions) {
    await this.syncSingleAction(action);
  }
}
```

## 测试方案

### 测试步骤

1. **断网测试**
   ```
   1. 断开网络连接
   2. 启动Timer并停止，创建事件
   3. 检查localStorage中的actionQueue是否包含该action
   4. 恢复网络连接
   5. 观察控制台日志，应该看到：
      - "🌐 [Network] Network is back online"
      - "🔄 [Network] Executing sync after network recovery"
      - 事件同步成功
   ```

2. **长时间断网测试**
   ```
   1. 断开网络连接
   2. 创建多个Timer事件
   3. 保持断网超过60秒
   4. 恢复网络
   5. 验证所有事件都能同步成功
   ```

3. **刷新页面测试**
   ```
   1. 断网状态下创建事件
   2. 刷新页面
   3. 恢复网络
   4. 验证事件能自动同步
   ```

### 预期日志

```
// 断网时
📴 [Network] Network is offline, sync will be queued
🔍 [RECORD LOCAL ACTION] Network is offline, action will be synced when online

// 联网后
🌐 [Network] Network is back online, triggering sync...
🔄 [Network] Executing sync after network recovery
🔄 [performSync] Starting sync cycle...
📊 [Sync] Pending local actions: {"total": 3, "byRetryCount": {"0": 3}}
✅ [SYNC SINGLE ACTION] Action completed successfully
```

## 代码修改位置

需要修改的文件：
- `src/services/ActionBasedSyncManager.ts`

需要添加的方法：
1. `setupNetworkListeners()` - 设置网络监听
2. `isNetworkError()` - 判断网络错误
3. 修改 `syncSingleAction()` - 增加重试次数和智能判断
4. 修改 `recordLocalAction()` - 添加网络检查
5. 修改 `syncPendingLocalActions()` - 优先处理失败次数少的

## 兼容性说明

- `navigator.onLine` - 所有现代浏览器支持
- `window.addEventListener('online/offline')` - IE9+ 支持
- 对现有功能无影响，纯新增功能

## 总结

通过添加网络状态监听和改进重试机制，可以确保：
1. ✅ 断网时创建的事件会被正确保存到队列
2. ✅ 联网后立即自动同步（1秒延迟）
3. ✅ 长时间断网也能保持重试
4. ✅ 刷新页面后仍能继续同步

这个修复方案不会破坏现有功能，只是增加了更可靠的同步保障。
