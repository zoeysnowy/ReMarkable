import React, { useState, useEffect, useCallback } from 'react';
import { Event } from '../types';
import { MicrosoftCalendarService } from '../services/MicrosoftCalendarService';
import { formatTimeForStorage, parseLocalTimeString, formatTimeForInput, formatDateForInput, formatDisplayTime, formatDateTimeForInput } from '../utils/timeUtils';
import { STORAGE_KEYS } from '../constants/storage';
import { PersistentStorage, PERSISTENT_OPTIONS } from '../utils/persistentStorage';
import DescriptionEditor from './DescriptionEditor';

interface EventTag {
  id: string;
  name: string;
  color: string;
  outlookCalendarId?: string;
  category: 'ongoing' | 'planning';
}

interface UnifiedTimelineProps {
  onStartTimer: (taskTitle: string) => void;
  microsoftService?: MicrosoftCalendarService;
  syncManager?: any; // ActionBasedSyncManager instance
  lastSyncTime?: Date | null;
}

export const UnifiedTimeline: React.FC<UnifiedTimelineProps> = ({ 
  onStartTimer, 
  microsoftService,
  syncManager,
  lastSyncTime
}) => {
  console.log('üîç [UnifiedTimeline] Component rendered with syncManager:', !!syncManager);
  console.log('üîç [UnifiedTimeline] syncManager type:', typeof syncManager);
  
  const [events, setEvents] = useState<Event[]>([]);
  const [showAddForm, setShowAddForm] = useState(false);
  const [selectedDate, setSelectedDate] = useState(new Date());
  const [editingEvent, setEditingEvent] = useState<Event | null>(null);
  const [eventTags, setEventTags] = useState<EventTag[]>([]);
  
  // DescriptionEditor states
  const [showDescriptionEditor, setShowDescriptionEditor] = useState(false);
  const [editingEventForDescription, setEditingEventForDescription] = useState<Event | null>(null);
  
  const [formData, setFormData] = useState({
    title: '',
    description: '',
    startTime: '',
    endTime: '',
    location: '',
    isAllDay: false,
    reminder: 15,
    category: 'planning' as 'ongoing' | 'planning',
    tagId: ''
  });

  // Êó∂Èó¥ÊòæÁ§∫ÈÖçÁΩÆ
  const [ongoingDaysConfig, setOngoingDaysConfig] = useState(7);
  const [showOngoingConfig, setShowOngoingConfig] = useState(false);
  const [tempOngoingDays, setTempOngoingDays] = useState('7');

  // Âä†ËΩΩ‰∫ã‰ª∂Êï∞ÊçÆ
  const loadEvents = useCallback(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.EVENTS);
    if (saved) {
      const allEvents = JSON.parse(saved);
      setEvents(allEvents);
    } else {
      // Â¶ÇÊûúÊ≤°Êúâ‰∫ã‰ª∂Êï∞ÊçÆÔºåÂàõÂª∫‰∏Ä‰∫õÊµãËØï‰∫ã‰ª∂
      const testEvents = [
        {
          id: 'test-event-1',
          title: 'ÊµãËØïÂ∑•‰Ωú‰∫ã‰ª∂',
          description: 'ËøôÊòØ‰∏Ä‰∏™ÊµãËØïÂ∑•‰Ωú‰∫ã‰ª∂ÁöÑÊèèËø∞ÔºåÁî®‰∫éÂ±ïÁ§∫Áªü‰∏ÄÊó∂Èó¥Á∫øÂäüËÉΩ',
          startTime: formatTimeForStorage(new Date(Date.now() - 2 * 60 * 60 * 1000)),
          endTime: formatTimeForStorage(new Date(Date.now() - 1 * 60 * 60 * 1000)),
          tagId: 'work',
          isAllDay: false,
          category: 'ongoing',
          createdAt: formatTimeForStorage(new Date()),
          updatedAt: formatTimeForStorage(new Date())
        },
        {
          id: 'test-event-2', 
          title: 'ÊµãËØïÁîüÊ¥ª‰∫ã‰ª∂',
          description: 'ËøôÊòØ‰∏Ä‰∏™ÊµãËØïÁîüÊ¥ª‰∫ã‰ª∂ÁöÑÊèèËø∞',
          startTime: formatTimeForStorage(new Date(Date.now() - 4 * 60 * 60 * 1000)),
          endTime: formatTimeForStorage(new Date(Date.now() - 3 * 60 * 60 * 1000)),
          tagId: 'life',
          isAllDay: false,
          category: 'ongoing',
          createdAt: formatTimeForStorage(new Date()),
          updatedAt: formatTimeForStorage(new Date())
        },
        {
          id: 'test-event-future-1',
          title: 'Êú™Êù•ÁöÑ‰ºöËÆÆ',
          description: 'ÊòéÂ§©ÁöÑÈáçË¶Å‰ºöËÆÆ',
          startTime: formatTimeForStorage(new Date(Date.now() + 24 * 60 * 60 * 1000)),
          endTime: formatTimeForStorage(new Date(Date.now() + 25 * 60 * 60 * 1000)),
          tagId: 'work',
          isAllDay: false,
          category: 'planning',
          createdAt: formatTimeForStorage(new Date()),
          updatedAt: formatTimeForStorage(new Date())
        }
      ];
      
      localStorage.setItem(STORAGE_KEYS.EVENTS, JSON.stringify(testEvents));
      setEvents(testEvents);
    }
  }, []);

  // Âä†ËΩΩÊ†áÁ≠æÊï∞ÊçÆ
  const loadEventTags = useCallback(() => {
    const saved = localStorage.getItem(STORAGE_KEYS.EVENT_TAGS);
    if (saved) {
      setEventTags(JSON.parse(saved));
    }
  }, []);

  useEffect(() => {
    // Âä†ËΩΩÁî®Êà∑ËÆæÁΩÆ
    try {
      const settings = localStorage.getItem(STORAGE_KEYS.SETTINGS);
      if (settings) {
        const parsedSettings = JSON.parse(settings);
        const savedOngoingDays = parsedSettings.ongoingDays || parsedSettings.ongoing || 7;
        setOngoingDaysConfig(savedOngoingDays);
        setTempOngoingDays(savedOngoingDays.toString());
        console.log(`‚öôÔ∏è [Timeline] Loaded ongoingDays config: ${savedOngoingDays} days`);
      } else {
        // üîß Â¶ÇÊûúÊ≤°ÊúâËÆæÁΩÆÔºåÂàõÂª∫ÈªòËÆ§ËÆæÁΩÆÂπ∂Á´ãÂç≥‰øùÂ≠ò
        const defaultSettings = { ongoingDays: 7 };
        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(defaultSettings));
        setOngoingDaysConfig(7);
        setTempOngoingDays('7');
        console.log(`‚öôÔ∏è [Timeline] Created default ongoingDays config: 7 days`);
      }
    } catch (error) {
      console.error('‚ùå Error loading ongoingDays config:', error);
      // Âá∫ÈîôÊó∂‰πüË¶ÅËÆæÁΩÆÈªòËÆ§ÂÄº
      const defaultSettings = { ongoingDays: 7 };
      localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(defaultSettings));
      setOngoingDaysConfig(7);
      setTempOngoingDays('7');
    }
    
    // üîÑ ÁõëÂê¨ÂêåÊ≠•ÂÆåÊàê‰∫ã‰ª∂
    const handleSyncCompleted = () => {
      console.log('üîÑ [Timeline] Sync completed, reloading events');
      loadEvents();
    };

    // üîÑ ÁõëÂê¨Êú¨Âú∞‰∫ã‰ª∂ÂèòÂåñÔºàÂ¶ÇÊó•ÂéÜËøÅÁßªÔºâ
    const handleLocalEventsChanged = (event: unknown) => {
      const customEvent = event as CustomEvent;
      console.log('üîÑ [Timeline] Local events changed, reloading events:', customEvent.detail);
      loadEvents();
    };

    window.addEventListener('action-sync-completed', handleSyncCompleted);
    window.addEventListener('outlook-sync-completed', handleSyncCompleted);
    window.addEventListener('local-events-changed', handleLocalEventsChanged as any);
    
    loadEvents();
    loadEventTags();
    
    // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
    return () => {
      window.removeEventListener('action-sync-completed', handleSyncCompleted);
      window.removeEventListener('outlook-sync-completed', handleSyncCompleted);
      window.removeEventListener('local-events-changed', handleLocalEventsChanged as any);
    };
  }, [loadEvents, loadEventTags]);

  // ÂàÜÁ¶ªËøáÂéªÂíåÊú™Êù•ÁöÑ‰∫ã‰ª∂
  const now = new Date();
  const cutoffTime = new Date(now.getFullYear(), now.getMonth(), now.getDate() - ongoingDaysConfig);
  
  const pastEvents = events.filter(event => {
    const eventTime = parseLocalTimeString(event.startTime);
    return eventTime.getTime() < now.getTime() && eventTime.getTime() >= cutoffTime.getTime();
  }).sort((a, b) => {
    const timeA = parseLocalTimeString(a.startTime).getTime();
    const timeB = parseLocalTimeString(b.startTime).getTime();
    return timeB - timeA; // ÂÄíÂ∫èÔºöÊúÄÊñ∞ÁöÑÂú®Ââç
  });

  const futureEvents = events.filter(event => {
    const eventTime = parseLocalTimeString(event.startTime);
    return eventTime.getTime() >= now.getTime();
  }).sort((a, b) => {
    const timeA = parseLocalTimeString(a.startTime).getTime();
    const timeB = parseLocalTimeString(b.startTime).getTime();
    return timeA - timeB; // Ê≠£Â∫èÔºöÊúÄÊó©ÁöÑÂú®Ââç
  });

  // Ëé∑ÂèñÊ†áÁ≠æÂà∞Êó•ÂéÜÁöÑÊò†Â∞Ñ
  const getTargetCalendarId = (event: Event): string | null => {
    if (!event.tagId) return null;
    
    try {
      const savedTags = PersistentStorage.getItem(STORAGE_KEYS.HIERARCHICAL_TAGS, PERSISTENT_OPTIONS.TAGS);
      if (!savedTags) return null;
      
      const availableTags = flattenTags(savedTags);
      const foundTag = availableTags.find(tag => tag.id === event.tagId);
      
      console.log('üîç [getTargetCalendarId] Event', `"${event.title}"`, 'with tagId', `"${event.tagId}"`, {
        foundTag,
        calendarMapping: foundTag?.calendarMapping || null,
        calendarId: foundTag?.calendarMapping?.calendarId || null,
        availableTags
      });
      
      return foundTag?.calendarMapping?.calendarId || null;
    } catch (error) {
      console.error('‚ùå [getTargetCalendarId] Error:', error);
      return null;
    }
  };

  // ÊâÅÂπ≥ÂåñÊ†áÁ≠æ
  const flattenTags = (tags: any[]): any[] => {
    const result: any[] = [];
    
    const flatten = (tagList: any[], parentName = '') => {
      tagList.forEach(tag => {
        const displayName = parentName ? `${parentName} > ${tag.name}` : tag.name;
        result.push({
          ...tag,
          displayName,
          parentName
        });
        
        if (tag.children && tag.children.length > 0) {
          flatten(tag.children, displayName);
        }
      });
    };
    
    flatten(tags);
    return result;
  };

  // ÂêåÊ≠•‰∫ã‰ª∂Âà∞ Outlook
  const syncEventToOutlook = async (event: Event): Promise<string | null> => {
    if (!microsoftService) {
      throw new Error('Microsoft Calendar service not available');
    }
    
    const targetCalendarId = getTargetCalendarId(event);
    
    if (targetCalendarId) {
      console.log(`üéØ [UnifiedTimeline] Syncing event "${event.title}" to calendar:`, targetCalendarId);
      return await microsoftService.syncEventToCalendar(event, targetCalendarId);
    } else {
      console.log(`üéØ [UnifiedTimeline] Syncing event "${event.title}" to default calendar`);
      return await microsoftService.createEvent(event);
    }
  };

  // Ê∑ªÂä†/ÁºñËæë‰∫ã‰ª∂
  const addEvent = async () => {
    if (!formData.title) return;

    try {
      let startTime, endTime;
      
      if (formData.isAllDay) {
        // üîß ‰ΩøÁî®Êú¨Âú∞Êó•ÊúüÈÅøÂÖçÊó∂Âå∫ËΩ¨Êç¢ÈóÆÈ¢ò
        const year = selectedDate.getFullYear();
        const month = (selectedDate.getMonth() + 1).toString().padStart(2, '0');
        const day = selectedDate.getDate().toString().padStart(2, '0');
        const selectedDateStr = `${year}-${month}-${day}`;
        
        const allDayStart = new Date(`${selectedDateStr}T00:00:00`);
        const allDayEnd = new Date(`${selectedDateStr}T23:59:59`);
        
        startTime = formatTimeForStorage(allDayStart);
        endTime = formatTimeForStorage(allDayEnd);
      } else {
        // üîß ‰ΩøÁî®Êú¨Âú∞Êó•ÊúüÈÅøÂÖçÊó∂Âå∫ËΩ¨Êç¢ÈóÆÈ¢ò
        const year = selectedDate.getFullYear();
        const month = (selectedDate.getMonth() + 1).toString().padStart(2, '0');
        const day = selectedDate.getDate().toString().padStart(2, '0');
        const selectedDateStr = `${year}-${month}-${day}`;
        
        const startDateTime = new Date(`${selectedDateStr}T${formData.startTime}:00`);
        const endDateTime = new Date(`${selectedDateStr}T${formData.endTime}:00`);
        
        startTime = formatTimeForStorage(startDateTime);
        endTime = formatTimeForStorage(endDateTime);
      }

      const saved = localStorage.getItem(STORAGE_KEYS.EVENTS);
      const existingEvents = saved ? JSON.parse(saved) : [];

      if (editingEvent) {
        // ÁºñËæëÁé∞Êúâ‰∫ã‰ª∂
        const eventIndex = existingEvents.findIndex((e: Event) => e.id === editingEvent.id);
        if (eventIndex !== -1) {
          const originalEvent = existingEvents[eventIndex]; // ‰øùÂ≠òÂéüÂßã‰∫ã‰ª∂Êï∞ÊçÆ
          const updatedEvent: Event = {
            ...existingEvents[eventIndex],
            title: formData.title,
            description: formData.description,
            startTime,
            endTime,
            location: formData.location || '',
            isAllDay: formData.isAllDay,
            category: formData.category,
            tagId: formData.tagId || '',
            updatedAt: formatTimeForStorage(new Date()),
          };

          existingEvents[eventIndex] = updatedEvent;
          
          // ÂêåÊ≠•Âà∞ syncManager
          if (syncManager) {
            try {
              await syncManager.recordLocalAction('update', 'event', updatedEvent.id, updatedEvent, originalEvent);
              console.log('‚úÖ Event updated and synced through syncManager');
            } catch (error) {
              console.error('‚ùå Failed to sync updated event through syncManager:', error);
            }
          }
        }
      } else {
        // ÂàõÂª∫Êñ∞‰∫ã‰ª∂
        const newEvent: Event = {
          id: Date.now().toString(),
          title: formData.title,
          description: formData.description,
          startTime,
          endTime,
          location: formData.location || '',
          isAllDay: formData.isAllDay,
          category: formData.category,
          tagId: formData.tagId || '',
          createdAt: formatTimeForStorage(new Date()),
          updatedAt: formatTimeForStorage(new Date()),
        };

        existingEvents.push(newEvent);

        // ÂêåÊ≠•Âà∞ syncManager
        if (syncManager) {
          try {
            await syncManager.recordLocalAction('create', 'event', newEvent.id, newEvent);
            console.log('‚úÖ Event created and synced through syncManager');
          } catch (error) {
            console.error('‚ùå Failed to sync new event through syncManager:', error);
          }
        }
      }
      
      localStorage.setItem(STORAGE_KEYS.EVENTS, JSON.stringify(existingEvents));
      setEvents(existingEvents);

      // ÈáçÁΩÆË°®Âçï
      setFormData({
        title: '',
        description: '',
        startTime: '',
        endTime: '',
        location: '',
        isAllDay: false,
        reminder: 15,
        category: 'planning',
        tagId: ''
      });
      setShowAddForm(false);
      setEditingEvent(null);
    } catch (error) {
      console.error('‰øùÂ≠ò‰∫ã‰ª∂Â§±Ë¥•:', error);
    }
  };

  // Âà†Èô§‰∫ã‰ª∂
  const deleteEvent = (eventId: string) => {
    console.log('üóëÔ∏è [UnifiedTimeline] deleteEvent called for:', eventId);
    console.log('üóëÔ∏è [UnifiedTimeline] syncManager available:', !!syncManager);
    console.log('üóëÔ∏è [UnifiedTimeline] syncManager value:', syncManager);
    
    const saved = localStorage.getItem(STORAGE_KEYS.EVENTS);
    if (saved) {
      const existingEvents = JSON.parse(saved);
      const eventToDelete = existingEvents.find((e: Event) => e.id === eventId);
      console.log('üóëÔ∏è [UnifiedTimeline] Found event to delete:', eventToDelete?.title);
      
      const updatedEvents = existingEvents.filter((e: Event) => e.id !== eventId);
      localStorage.setItem(STORAGE_KEYS.EVENTS, JSON.stringify(updatedEvents));
      setEvents(updatedEvents);
      
      // ÂêåÊ≠•Âà†Èô§Êìç‰Ωú - ‰ΩøÁî®window.syncManager‰Ωú‰∏∫Â§áÈÄâÊñπÊ°à
      const activeSyncManager = syncManager || (window as any).syncManager;
      console.log('üóëÔ∏è [UnifiedTimeline] Active syncManager:', !!activeSyncManager);
      
      if (activeSyncManager) {
        if (eventToDelete) {
          console.log('üóëÔ∏è [UnifiedTimeline] Calling syncManager.recordLocalAction for DELETE');
          activeSyncManager.recordLocalAction('delete', 'event', eventId, null, eventToDelete);
        } else {
          console.log('‚ùå [UnifiedTimeline] Event to delete not found in localStorage');
        }
      } else {
        console.log('‚ùå [UnifiedTimeline] syncManager is not available - DELETE will not sync to Outlook!');
        console.log('‚ùå [UnifiedTimeline] Available on window?', !!(window as any).syncManager);
      }
    } else {
      console.log('‚ùå [UnifiedTimeline] No events found in localStorage');
    }
  };

  // ÈáçÊñ∞ÂêåÊ≠•‰∫ã‰ª∂
  const resyncEvent = async (event: Event) => {
    try {
      console.log('üîÑ Re-syncing event to Outlook:', event.title);
      
      // ‰ΩøÁî® ActionBasedSyncManager Êù•Â§ÑÁêÜÈáçÊñ∞ÂêåÊ≠•ÔºåËøôÊ†∑‰ºöÊ≠£Á°ÆÂ§ÑÁêÜÊõ¥Êñ∞ÈÄªËæë
      if (syncManager) {
        // Â∞ÜÈáçÊñ∞ÂêåÊ≠•‰Ωú‰∏∫Êõ¥Êñ∞Êìç‰ΩúÂ§ÑÁêÜÔºåËøôÊ†∑‰ºöËß¶ÂèëÊ≠£Á°ÆÁöÑÂêåÊ≠•ÈÄªËæë
        await syncManager.recordLocalAction('update', 'event', event.id, event, event);
        console.log('‚úÖ Re-sync successful through syncManager');
      } else {
        // Â¶ÇÊûú syncManager ‰∏çÂèØÁî®ÔºåÂõûÈÄÄÂà∞Áõ¥Êé•ÂàõÂª∫
        await syncEventToOutlook(event);
        console.log('‚úÖ Re-sync successful (fallback)');
      }
    } catch (error) {
      console.error('‚ùå Re-sync failed:', error);
    }
  };

  // Ê∏≤Êüì‰∫ã‰ª∂È°π
  const renderEventItem = (event: Event, isLeftColumn: boolean = false) => (
    <div 
      key={event.id}
      style={{
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: '8px 12px',
        marginBottom: '6px',
        backgroundColor: isLeftColumn ? '#f8f9fa' : '#fff',
        border: '1px solid #e9ecef',
        borderRadius: '4px',
        fontSize: '0.85rem'
      }}
    >
      <div style={{ flex: 1 }}>
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          justifyContent: 'space-between',
          marginBottom: event.description ? '4px' : '0'
        }}>
          <span style={{ color: '#495057', fontWeight: '500' }}>
            {event.title}
          </span>
          <small style={{ color: '#6c757d', marginLeft: '8px' }}>
            {formatDisplayTime(event.startTime)}
          </small>
        </div>
        
        {event.description && event.description.trim() && (
          <div style={{ 
            fontSize: '0.75rem', 
            color: '#6c757d',
            lineHeight: '1.3',
            marginBottom: '2px',
            maxHeight: '2.6em',
            overflow: 'hidden',
            display: '-webkit-box',
            WebkitLineClamp: 2,
            WebkitBoxOrient: 'vertical',
            whiteSpace: 'pre-wrap'
          }}>
            {event.description}
          </div>
        )}
        
        {/* ÊòæÁ§∫Ê†áÁ≠æ */}
        {event.tagId && (
          <div style={{ 
            fontSize: '0.7rem', 
            color: '#007bff',
            marginTop: '4px'
          }}>
            #{getTagDisplayName(event.tagId)}
          </div>
        )}
      </div>
          
      <div style={{ display: 'flex', gap: '4px', marginLeft: '8px' }}>
        <button
          onClick={(e) => {
            e.stopPropagation();
            setEditingEvent(event);
            setFormData({
              title: event.title,
              description: event.description || '',
              startTime: formatTimeForInput(event.startTime),
              endTime: formatTimeForInput(event.endTime),
              location: event.location || '',
              isAllDay: event.isAllDay || false,
              reminder: 15,
              category: (event.category as 'ongoing' | 'planning') || 'planning',
              tagId: event.tagId || ''
            });
            setSelectedDate(parseLocalTimeString(event.startTime));
          }}
          style={{
            background: 'red',
            border: 'none',
            cursor: 'pointer',
            fontSize: '0.9rem',
            padding: '2px 4px',
            borderRadius: '2px',
            color: 'white'
          }}
          title="ÁºñËæë"
        >
          APP
        </button>
        <button
          onClick={() => resyncEvent(event)}
          style={{
            background: '#28a745',
            border: 'none',
            cursor: 'pointer',
            fontSize: '0.8rem',
            padding: '2px 4px',
            borderRadius: '2px',
            color: 'white'
          }}
          title="ÈáçÊñ∞ÂêåÊ≠•"
        >
          üîÑ
        </button>
        <button
          onClick={(e) => {
            e.stopPropagation();
            if (window.confirm('Á°ÆÂÆöË¶ÅÂà†Èô§ËøôÊù°ËÆ∞ÂΩïÂêóÔºü')) {
              deleteEvent(event.id);
            }
          }}
          style={{
            background: 'none',
            border: 'none',
            cursor: 'pointer',
            fontSize: '0.9rem',
            padding: '2px 4px',
            borderRadius: '2px',
            color: '#dc3545'
          }}
          title="Âà†Èô§"
        >
          üóëÔ∏è
        </button>
      </div>
    </div>
  );

  // Ëé∑ÂèñÊ†áÁ≠æÊòæÁ§∫ÂêçÁß∞
  const getTagDisplayName = (tagId: string): string => {
    try {
      const savedTags = PersistentStorage.getItem(STORAGE_KEYS.HIERARCHICAL_TAGS, PERSISTENT_OPTIONS.TAGS);
      if (!savedTags) return 'Êú™ÂàÜÁ±ª';
      
      const findTagName = (tags: any[], tagId: string): string => {
        for (const tag of tags) {
          if (tag.id === tagId) return tag.name;
          if (tag.children) {
            const childName = findTagName(tag.children, tagId);
            if (childName) return childName;
          }
        }
        return 'Êú™ÂàÜÁ±ª';
      };
      
      return findTagName(savedTags, tagId);
    } catch (error) {
      return 'Êú™ÂàÜÁ±ª';
    }
  };

  // Â∫îÁî®Êó∂Èó¥ËåÉÂõ¥ÈÖçÁΩÆ
  const applyOngoingConfig = () => {
    const days = parseInt(tempOngoingDays);
    if (days > 0 && days <= 30) {
      setOngoingDaysConfig(days);
      setShowOngoingConfig(false);
      
      // üîß ‰øùÂ≠òÂà∞localStorageËÆæÁΩÆ‰∏≠
      try {
        const currentSettings = localStorage.getItem(STORAGE_KEYS.SETTINGS);
        const settings = currentSettings ? JSON.parse(currentSettings) : {};
        settings.ongoingDays = days;
        localStorage.setItem(STORAGE_KEYS.SETTINGS, JSON.stringify(settings));
        console.log(`‚öôÔ∏è [Timeline] Saved ongoingDays config: ${days} days`);
        
        // Ëß¶Âèë‰∫ã‰ª∂Âà∑Êñ∞‰ª•Â∫îÁî®Êñ∞ÁöÑÂ§©Êï∞ËÆæÁΩÆ
        if (syncManager && microsoftService && microsoftService.isSignedIn()) {
          console.log('üîÑ [Timeline] Refreshing events with new days config');
          loadEvents();
        }
      } catch (error) {
        console.error('‚ùå Error saving ongoingDays config:', error);
      }
    }
  };

  return (
    <div style={{ 
      display: 'flex', 
      height: '100%', 
      gap: '20px',
      background: 'rgba(255, 255, 255, 0.95)',
      borderRadius: '12px',
      padding: '20px',
      boxShadow: '0 4px 16px rgba(0, 0, 0, 0.1)',
      border: '1px solid rgba(255, 255, 255, 0.3)'
    }}>
      {/* Â∑¶‰æßÔºöÊó∂ÂÖâÊó•ÂøóÔºàËøáÂéªÁöÑ‰∫ã‰ª∂Ôºâ */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          justifyContent: 'space-between',
          marginBottom: '16px',
          padding: '0 4px'
        }}>
          <h3 style={{ margin: 0, fontSize: '1.2rem', color: '#495057' }}>
            ‚è∞ Êó∂ÂÖâÊó•Âøó
          </h3>
          {/* ÂêåÊ≠•Áä∂ÊÄÅ‰ø°ÊÅØ */}
          <div style={{ fontSize: '0.8rem', color: '#6c757d' }}>
            üîÑ {microsoftService && microsoftService.isSignedIn() ? 'Â∑≤ËøûÊé•' : 'Êú™ËøûÊé•'}
            {lastSyncTime && microsoftService && microsoftService.isSignedIn() && (
              <span style={{ marginLeft: '8px', color: '#28a745' }}>
                | ÊúÄÂêéÂêåÊ≠•: {lastSyncTime.toLocaleTimeString()}
              </span>
            )}
          </div>
          <div style={{ position: 'relative' }}>
            <button
              onClick={() => setShowOngoingConfig(!showOngoingConfig)}
              style={{
                background: 'none',
                border: '1px solid #dee2e6',
                cursor: 'pointer',
                fontSize: '0.75rem',
                padding: '4px 8px',
                borderRadius: '4px',
                color: '#6c757d'
              }}
              title="ÈÖçÁΩÆÊòæÁ§∫Â§©Êï∞"
            >
              ‚öôÔ∏è {ongoingDaysConfig}Â§©
            </button>
            
            {showOngoingConfig && (
              <div style={{
                position: 'absolute',
                top: '100%',
                right: 0,
                marginTop: '4px',
                padding: '8px',
                backgroundColor: 'white',
                border: '1px solid #dee2e6',
                borderRadius: '4px',
                boxShadow: '0 2px 4px rgba(0,0,0,0.1)',
                zIndex: 1000,
                display: 'flex',
                alignItems: 'center',
                gap: '8px',
                minWidth: '200px'
              }}>
                <span style={{ color: '#666', whiteSpace: 'nowrap', fontSize: '0.75rem' }}>ÊòæÁ§∫Â§©Êï∞:</span>
                <input
                  type="number"
                  min="1"
                  max="30"
                  value={tempOngoingDays}
                  onChange={(e) => setTempOngoingDays(e.target.value)}
                  style={{
                    width: '60px',
                    padding: '4px 6px',
                    border: '1px solid #ccc',
                    borderRadius: '4px',
                    fontSize: '0.75rem',
                    textAlign: 'center'
                  }}
                />
                <button
                  onClick={applyOngoingConfig}
                  style={{
                    padding: '4px 8px',
                    fontSize: '0.75rem',
                    backgroundColor: '#28a745',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer'
                  }}
                >
                  Á°ÆÂÆö
                </button>
                <button
                  onClick={() => setShowOngoingConfig(false)}
                  style={{
                    padding: '4px 8px',
                    fontSize: '0.75rem',
                    backgroundColor: '#6c757d',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px',
                    cursor: 'pointer'
                  }}
                >
                  ÂèñÊ∂à
                </button>
              </div>
            )}
          </div>
        </div>

        <div style={{ 
          flex: 1, 
          overflowY: 'auto',
          border: '1px solid #dee2e6',
          borderRadius: '6px',
          padding: '12px',
          backgroundColor: '#f8f9fa'
        }}>
          {pastEvents.length === 0 ? (
            <div style={{
              padding: '20px',
              textAlign: 'center',
              color: '#666',
              fontSize: '0.9rem'
            }}>
              ÊöÇÊó†ÂéÜÂè≤ËÆ∞ÂΩï
            </div>
          ) : (
            pastEvents.map(event => renderEventItem(event, true))
          )}
        </div>
      </div>

      {/* Âè≥‰æßÔºöÊàëÁöÑÊó•Á®ãÔºàÊú™Êù•ÁöÑ‰∫ã‰ª∂Ôºâ */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column' }}>
        <div style={{ 
          display: 'flex', 
          alignItems: 'center', 
          justifyContent: 'space-between',
          marginBottom: '16px',
          padding: '0 4px'
        }}>
          <h3 style={{ margin: 0, fontSize: '1.2rem', color: '#495057' }}>
            üìÖ ÊàëÁöÑÊó•Á®ã
          </h3>
          {/* ÂêåÊ≠•Áä∂ÊÄÅ‰ø°ÊÅØ */}
          <div style={{ fontSize: '0.8rem', color: '#6c757d', marginRight: '10px' }}>
            üîÑ {microsoftService && microsoftService.isSignedIn() ? 'Â∑≤ËøûÊé•' : 'Êú™ËøûÊé•'}
            {lastSyncTime && microsoftService && microsoftService.isSignedIn() && (
              <span style={{ marginLeft: '8px', color: '#28a745' }}>
                | ÊúÄÂêéÂêåÊ≠•: {lastSyncTime.toLocaleTimeString()}
              </span>
            )}
          </div>
          <button
            onClick={() => setShowAddForm(true)}
            style={{
              backgroundColor: '#007bff',
              color: 'white',
              border: 'none',
              padding: '8px 16px',
              borderRadius: '4px',
              cursor: 'pointer',
              fontSize: '0.9rem'
            }}
          >
            ‚ûï Ê∑ªÂä†Êó•Á®ã
          </button>
        </div>

        <div style={{ 
          flex: 1, 
          overflowY: 'auto',
          border: '1px solid #dee2e6',
          borderRadius: '6px',
          padding: '12px',
          backgroundColor: '#fff'
        }}>
          {futureEvents.length === 0 ? (
            <div style={{
              padding: '20px',
              textAlign: 'center',
              color: '#666',
              fontSize: '0.9rem'
            }}>
              ÊöÇÊó†Êú™Êù•Êó•Á®ã
            </div>
          ) : (
            futureEvents.map(event => renderEventItem(event, false))
          )}
        </div>
      </div>

      {/* Ê∑ªÂä†/ÁºñËæë‰∫ã‰ª∂ÂºπÁ™ó */}
      {(showAddForm || editingEvent) && (
        <div style={{
          position: 'fixed',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0,
          backgroundColor: 'rgba(0, 0, 0, 0.5)',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
          zIndex: 1000
        }}>
          <div style={{
            backgroundColor: 'white',
            padding: '24px',
            borderRadius: '8px',
            width: '90%',
            maxWidth: '600px',
            maxHeight: '80vh',
            overflow: 'auto'
          }}>
            <h3>{editingEvent ? 'ÁºñËæë‰∫ã‰ª∂' : 'Ê∑ªÂä†Êñ∞‰∫ã‰ª∂'}</h3>
            
            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'block', marginBottom: '4px' }}>Ê†áÈ¢ò *</label>
              <input
                type="text"
                value={formData.title}
                onChange={(e) => setFormData({...formData, title: e.target.value})}
                style={{
                  width: '100%',
                  padding: '8px',
                  border: '1px solid #ddd',
                  borderRadius: '4px'
                }}
                placeholder="ËØ∑ËæìÂÖ•‰∫ã‰ª∂Ê†áÈ¢ò"
              />
            </div>

            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'block', marginBottom: '4px' }}>ÊèèËø∞</label>
              <textarea
                value={formData.description}
                onChange={(e) => setFormData({...formData, description: e.target.value})}
                rows={4}
                style={{
                  width: '100%',
                  padding: '8px',
                  border: '1px solid #ddd',
                  borderRadius: '4px',
                  resize: 'vertical'
                }}
                placeholder="ËØ∑ËæìÂÖ•‰∫ã‰ª∂ÊèèËø∞"
              />
            </div>

            {/* Êó∂Èó¥ÈÖçÁΩÆ */}
            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'flex', alignItems: 'center', marginBottom: '8px' }}>
                <input
                  type="checkbox"
                  checked={formData.isAllDay}
                  onChange={(e) => setFormData({...formData, isAllDay: e.target.checked})}
                  style={{ marginRight: '8px' }}
                />
                ÂÖ®Â§©‰∫ã‰ª∂
              </label>
              
              <div style={{ display: 'flex', gap: '12px', alignItems: 'center' }}>
                <div>
                  <label style={{ display: 'block', marginBottom: '4px' }}>Êó•Êúü</label>
                  <input
                    type="date"
                    value={formatDateForInput(selectedDate)}
                    onChange={(e) => setSelectedDate(new Date(e.target.value + 'T00:00:00'))}
                    style={{
                      padding: '8px',
                      border: '1px solid #ddd',
                      borderRadius: '4px'
                    }}
                  />
                </div>
                
                {!formData.isAllDay && (
                  <>
                    <div>
                      <label style={{ display: 'block', marginBottom: '4px' }}>ÂºÄÂßãÊó∂Èó¥</label>
                      <input
                        type="time"
                        value={formData.startTime}
                        onChange={(e) => setFormData({...formData, startTime: e.target.value})}
                        style={{
                          padding: '8px',
                          border: '1px solid #ddd',
                          borderRadius: '4px'
                        }}
                      />
                    </div>
                    
                    <div>
                      <label style={{ display: 'block', marginBottom: '4px' }}>ÁªìÊùüÊó∂Èó¥</label>
                      <input
                        type="time"
                        value={formData.endTime}
                        onChange={(e) => setFormData({...formData, endTime: e.target.value})}
                        style={{
                          padding: '8px',
                          border: '1px solid #ddd',
                          borderRadius: '4px'
                        }}
                      />
                    </div>
                  </>
                )}
              </div>
            </div>

            {/* Ê†áÁ≠æÈÄâÊã© */}
            <div style={{ marginBottom: '16px' }}>
              <label style={{ display: 'block', marginBottom: '4px' }}>Ê†áÁ≠æ</label>
              <select
                value={formData.tagId}
                onChange={(e) => setFormData({...formData, tagId: e.target.value})}
                style={{
                  width: '100%',
                  padding: '8px',
                  border: '1px solid #ddd',
                  borderRadius: '4px'
                }}
              >
                <option value="">ÈÄâÊã©Ê†áÁ≠æ</option>
                {(() => {
                  try {
                    const savedTags = PersistentStorage.getItem(STORAGE_KEYS.HIERARCHICAL_TAGS, PERSISTENT_OPTIONS.TAGS);
                    if (!savedTags) return [];
                    return flattenTags(savedTags);
                  } catch {
                    return [];
                  }
                })().map(tag => (
                  <option key={tag.id} value={tag.id}>
                    {tag.displayName}
                  </option>
                ))}
              </select>
            </div>

            <div style={{ display: 'flex', gap: '12px', justifyContent: 'flex-end' }}>
              <button
                onClick={() => {
                  setShowAddForm(false);
                  setEditingEvent(null);
                  setFormData({
                    title: '',
                    description: '',
                    startTime: '',
                    endTime: '',
                    location: '',
                    isAllDay: false,
                    reminder: 15,
                    category: 'planning',
                    tagId: ''
                  });
                }}
                style={{
                  padding: '8px 16px',
                  border: '1px solid #ddd',
                  borderRadius: '4px',
                  cursor: 'pointer',
                  backgroundColor: '#f8f9fa'
                }}
              >
                ÂèñÊ∂à
              </button>
              
              <button
                onClick={addEvent}
                style={{
                  padding: '8px 16px',
                  backgroundColor: '#007bff',
                  color: 'white',
                  border: 'none',
                  borderRadius: '4px',
                  cursor: 'pointer'
                }}
              >
                {editingEvent ? '‰øùÂ≠ò‰øÆÊîπ' : 'Ê∑ªÂä†‰∫ã‰ª∂'}
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default UnifiedTimeline;