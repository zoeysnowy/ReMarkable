<!DOCTYPE html>
<html>
<head>
  <title>矩阵算法性能测试</title>
  <style>
    body { font-family: monospace; padding: 20px; }
    .result { margin: 10px 0; padding: 10px; background: #f0f0f0; }
    .fast { color: green; }
    .slow { color: red; }
  </style>
</head>
<body>
  <h1>矩阵算法 vs 旧算法性能对比</h1>
  <div id="results"></div>

  <script>
    // 生成测试数据
    function generateTestData(eventCount, avgStatusesPerEvent) {
      const statusTypes = ['new', 'updated', 'deleted', 'done', 'missed'];
      const segments = [];
      
      for (let i = 0; i < eventCount; i++) {
        const statusCount = Math.floor(Math.random() * 3) + 1; // 1-3个状态
        const statuses = [];
        
        for (let j = 0; j < statusCount; j++) {
          const status = statusTypes[Math.floor(Math.random() * statusTypes.length)];
          if (!statuses.includes(status)) {
            statuses.push(status);
            segments.push({
              startIndex: i,
              endIndex: i,
              status: status,
              label: status.charAt(0).toUpperCase() + status.slice(1)
            });
          }
        }
      }
      
      return segments;
    }

    // 矩阵算法
    function matrixAlgorithm(segments) {
      const columnMap = new Map();
      
      if (segments.length === 0) return columnMap;
      
      // 步骤1: 构建矩阵
      const matrix = new Map();
      const maxEventIndex = Math.max(...segments.map(s => s.startIndex));
      
      segments.forEach(segment => {
        if (!matrix.has(segment.startIndex)) {
          matrix.set(segment.startIndex, new Map());
        }
        matrix.get(segment.startIndex).set(segment.status, segment);
      });
      
      // 步骤2: 纵向扫描合并
      const statusTypes = ['new', 'updated', 'deleted', 'done', 'missed'];
      const columns = [];
      
      statusTypes.forEach(status => {
        const continuousSegments = [];
        let currentGroup = [];
        
        for (let i = 0; i <= maxEventIndex; i++) {
          const segment = matrix.get(i)?.get(status);
          
          if (segment) {
            currentGroup.push(segment);
          } else if (currentGroup.length > 0) {
            continuousSegments.push(...currentGroup);
            currentGroup = [];
          }
        }
        
        if (currentGroup.length > 0) {
          continuousSegments.push(...currentGroup);
        }
        
        if (continuousSegments.length > 0) {
          columns.push({ status, segments: continuousSegments });
        }
      });
      
      // 步骤3: 分配列号
      columns.forEach((column, columnIndex) => {
        column.segments.forEach(segment => {
          columnMap.set(segment, columnIndex);
        });
      });
      
      return columnMap;
    }

    // 旧算法（简化版）
    function oldAlgorithm(segments) {
      const columnMap = new Map();
      const sortedSegments = [...segments].sort((a, b) => a.startIndex - b.startIndex);
      const statusColumnsAtLine = new Map();
      
      sortedSegments.forEach(segment => {
        const { startIndex, status } = segment;
        const prevLineColumns = statusColumnsAtLine.get(startIndex - 1);
        let column;
        
        if (prevLineColumns && prevLineColumns.has(status)) {
          column = prevLineColumns.get(status);
        } else {
          const occupiedColumns = new Set();
          
          const currentLineColumns = statusColumnsAtLine.get(startIndex);
          if (currentLineColumns) {
            currentLineColumns.forEach((col) => {
              occupiedColumns.add(col);
            });
          }
          
          sortedSegments.forEach(other => {
            if (other === segment) return;
            if (columnMap.has(other)) {
              const overlaps = !(other.endIndex < segment.startIndex || other.startIndex > segment.endIndex);
              if (overlaps) {
                occupiedColumns.add(columnMap.get(other));
              }
            }
          });
          
          column = 0;
          while (occupiedColumns.has(column)) {
            column++;
          }
        }
        
        columnMap.set(segment, column);
        
        for (let lineIndex = segment.startIndex; lineIndex <= segment.endIndex; lineIndex++) {
          if (!statusColumnsAtLine.has(lineIndex)) {
            statusColumnsAtLine.set(lineIndex, new Map());
          }
          statusColumnsAtLine.get(lineIndex).set(status, column);
        }
      });
      
      return columnMap;
    }

    // 性能测试
    function benchmark(algorithm, segments, name) {
      const iterations = 100;
      const times = [];
      
      for (let i = 0; i < iterations; i++) {
        const start = performance.now();
        algorithm(segments);
        const end = performance.now();
        times.push(end - start);
      }
      
      const avg = times.reduce((a, b) => a + b, 0) / times.length;
      const min = Math.min(...times);
      const max = Math.max(...times);
      
      return { name, avg, min, max };
    }

    // 运行测试
    const resultsDiv = document.getElementById('results');
    
    [10, 20, 50, 100, 200].forEach(eventCount => {
      const segments = generateTestData(eventCount, 2);
      
      const matrixResult = benchmark(matrixAlgorithm, segments, '矩阵算法');
      const oldResult = benchmark(oldAlgorithm, segments, '旧算法');
      
      const speedup = (oldResult.avg / matrixResult.avg).toFixed(2);
      const faster = matrixResult.avg < oldResult.avg ? '矩阵' : '旧';
      
      resultsDiv.innerHTML += `
        <div class="result">
          <h3>${eventCount}个事件，${segments.length}个segments</h3>
          <p><strong class="${faster === '矩阵' ? 'fast' : 'slow'}">矩阵算法</strong>: 平均 ${matrixResult.avg.toFixed(3)}ms (最快 ${matrixResult.min.toFixed(3)}ms, 最慢 ${matrixResult.max.toFixed(3)}ms)</p>
          <p><strong class="${faster === '旧' ? 'fast' : 'slow'}">旧算法</strong>: 平均 ${oldResult.avg.toFixed(3)}ms (最快 ${oldResult.min.toFixed(3)}ms, 最慢 ${oldResult.max.toFixed(3)}ms)</p>
          <p><strong>性能提升</strong>: ${speedup}x ${faster === '矩阵' ? '✅ 更快' : '❌ 更慢'}</p>
        </div>
      `;
    });
  </script>
</body>
</html>
