
# 智能相对日期格式化引擎 - 设计文档

## 1. 核心理念

本引擎的目标是将一个绝对日期（`targetDate`）与一个基准日期（通常是 `today`）进行比较，然后输出一个最符合人类阅读习惯的、简洁的相对时间文本。

核心原则是**“优先级匹配”**：从最特殊、最口语化的规则开始检查，如果都不匹配，则逐步退回到更通用、更精确的格式。这确保了 “昨天” 会被优先显示，而不是 “1天前”。

## 2. 引擎输入与输出

*   **输入**:
    1.  `targetDate`: 需要被格式化的目标 `Date` 对象。
    2.  `today`: 作为基准的当前 `Date` 对象 (为了测试和一致性，应作为参数传入，而不是在函数内部直接获取)。
*   **输出**: 一个字符串，例如 `"明天"`, `"上周五"`, `"3周前"`, `"11月25日"`。

## 3. 格式化决策树 (优先级由高到低)

这是引擎的核心逻辑。程序将按顺序执行以下检查，一旦命中规则，则立即返回结果。

---

### **优先级 1: “核心口语” (The Core Vernacular)**

这是人们日常交流中最常用的词汇，优先级最高。

| 条件 (IF) | 输出 (RETURN) |
| :--- | :--- |
| `targetDate` 是 **今天** | `"今天"` |
| `targetDate` 是 **明天** | `"明天"` |
| `targetDate` 是 **昨天** | `"昨天"` |

---

### **优先级 2: “本周范围” (The Current Week Horizon)**

处理从“后天”到“本周日”的范围。

| 条件 (IF) | 输出 (RETURN) |
| :--- | :--- |
| `targetDate` 是 **后天** (今天 + 2天) | `"后天"` |
| `targetDate` 在 **今天之后** 且在 **本周日之内** | `"周X"` (例如: `"周五"`) |
| `targetDate` 在 **昨天之前** 且在 **本周一之后** | `"本周X"` (例如: `"本周二"`) |

*设计说明: 对于本周内已经过去的日子，加上“本周”前缀可以避免歧义。*

---

### **优先级 3: “邻近周范围” (The Adjacent Week Horizon)**

处理“上周”和“下周”的特定日子，这是非常高频的用法。

| 条件 (IF) | 输出 (RETURN) |
| :--- | :--- |
| `targetDate` 在 **下周** (从下周一到下周日) | `"下周X"` (例如: `"下周五"`) |
| `targetDate` 在 **上周** (从上周一到上周日) | `"上周X"` (例如: `"上周三"`) |

---

### **优先级 4: “X天/周/月 前后” (Numeric Deltas)**

如果日期更远，我们开始使用带数字的相对时间。

| 条件 (IF) | 输出 (RETURN) |
| :--- | :--- |
| `targetDate` 在未来 `3` 到 `14` 天内 | `"{N}天后"` (例如: `"5天后"`) |
| `targetDate` 在过去 `3` 到 `14` 天内 | `"{N}天前"` (例如: `"12天前"`) |
| `targetDate` 在未来 `3` 到 `8` 周内 | `"{N}周后"` (例如: `"3周后"`) |
| `targetDate` 在过去 `3` 到 `8` 周内 | `"{N}周前"` (例如: `"5周前"`) |
| `targetDate` 在 **下个月** | `"下个月"` |
| `targetDate` 在 **上个月** | `"上个月"` |
| `targetDate` 在未来 `3` 到 `11` 个月内 | `"{N}个月后"` (例如: `"4个月后"`) |
| `targetDate` 在过去 `3` 到 `11` 个月内 | `"{N}个月前"` (例如: `"7个月前"`) |

*设计说明: 我们在这里设定了14天和8周的阈值，超过这个范围，“X天/周前”的说法开始变得不直观，不如直接显示日期。*

---

### **优先级 5: “绝对日期” (The Absolute Fallback)**

当以上所有口语化规则都不适用时，我们回退到最清晰的绝对日期格式。

| 条件 (IF) | 输出 (RETURN) |
| :--- | :--- |
| `targetDate` 在 **今年** 内 | `"{月}月{日}日"` (例如: `"11月25日"`) |
| `targetDate` **不在今年** 内 | `"{年}/{月}/{日}"` (例如: `"2026/03/15"`) |

## 4. 伪代码实现

下面是一个JavaScript风格的伪代码，清晰地展示了上述决策树的实现逻辑。

```javascript
function formatRelativeDate(targetDate, today) {
  // 确保时间部分被忽略，只比较日期
  const startOfTarget = getStartOfDay(targetDate);
  const startOfToday = getStartOfDay(today);
  
  const daysDiff = (startOfTarget - startOfToday) / (1000 * 60 * 3600 * 24);
  const todayDayOfWeek = today.getDay(); // 0=Sunday, 1=Monday...

  // --- 优先级 1: 核心口语 ---
  if (daysDiff === 0) return "今天";
  if (daysDiff === 1) return "明天";
  if (daysDiff === -1) return "昨天";

  // --- 优先级 2: 本周范围 ---
  if (daysDiff === 2) return "后天";
  // 周日是0，要特殊处理。本周范围：从周一(1-todayDayOfWeek)到周日(7-todayDayOfWeek)
  if (daysDiff > 2 && daysDiff <= (todayDayOfWeek === 0 ? 0 : 7 - todayDayOfWeek)) {
    return formatDayOfWeek(targetDate); // e.g., "周五"
  }
  // 过去的日子，但仍在本周一之后
  if (daysDiff < -1 && daysDiff >= (1 - todayDayOfWeek)) {
    return "本" + formatDayOfWeek(targetDate); // e.g., "本周二"
  }

  // --- 优先级 3: 邻近周范围 ---
  // 下周: (7-todayDayOfWeek + 1) 到 (7-todayDayOfWeek + 7)
  if (daysDiff > (7 - todayDayOfWeek) && daysDiff <= (14 - todayDayOfWeek)) {
    return "下" + formatDayOfWeek(targetDate); // e.g., "下周三"
  }
  // 上周: (1-todayDayOfWeek - 7) 到 (1-todayDayOfWeek - 1)
  if (daysDiff < (1 - todayDayOfWeek) && daysDiff >= (-6 - todayDayOfWeek)) {
    return "上" + formatDayOfWeek(targetDate); // e.g., "上周日"
  }
  
  // --- 优先级 4: Numeric Deltas ---
  if (daysDiff > 0 && daysDiff <= 14) return `${daysDiff}天后`;
  if (daysDiff < 0 && daysDiff >= -14) return `${-daysDiff}天前`;
  
  const weeksDiff = Math.round(daysDiff / 7);
  if (weeksDiff > 1 && weeksDiff <= 8) return `${weeksDiff}周后`;
  if (weeksDiff < -1 && weeksDiff >= -8) return `${-weeksDiff}周前`;
  
  const monthsDiff = getMonthsDifference(targetDate, today);
  if (monthsDiff === 1) return "下个月";
  if (monthsDiff === -1) return "上个月";
  if (monthsDiff > 1 && monthsDiff <= 11) return `${monthsDiff}个月后`;
  if (monthsDiff < -1 && monthsDiff >= -11) return `${-monthsDiff}个月前`;

  // --- 优先级 5: 绝对日期 ---
  if (targetDate.getFullYear() === today.getFullYear()) {
    return formatDate(targetDate, "M月d日"); // e.g., "11月25日"
  } else {
    return formatDate(targetDate, "yyyy/M/d"); // e.g., "2026/3/15"
  }
}

// 辅助函数 (需要自行实现)
// getStartOfDay(date): 返回日期当天的00:00:00
// formatDayOfWeek(date): 将日期格式化为 "周X"
// getMonthsDifference(date1, date2): 计算两个日期的月份差
// formatDate(date, formatString): 按指定格式格式化日期
```

## 5. 结论

这份文档为你提供了一套完整的、可实现的“智能相对时间”格式化逻辑。它通过精细的优先级划分，确保了在任何场景下都能输出最符合直觉的日期文本，能极大地提升界面的清爽度和用户体验。这套规则可以直接交付给开发团队进行实现。

