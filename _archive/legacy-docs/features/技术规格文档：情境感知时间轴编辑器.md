
# **技术规格文档：情境感知时间轴编辑器 v1.0**

## 1. 核心愿景与设计哲学

本项目的目标是创建一个超越传统富文本编辑器的“个人时空叙事引擎”。用户输入的每一段文字不再是孤立的，而是被自动锚定在一条丰富的时间轴上。这条时间轴不仅记录**“何时”**（时间戳），还将融合**“何事”**（应用活动、媒体播放等），为用户的思绪和工作流提供完整的情境上下文。

**设计哲学：**

1.  **情境优先 (Context-First):** 编辑器不仅服务于文字，更服务于文字产生的完整情境。
2.  **无感记录 (Frictionless Logging):** 核心情境数据（时间、应用活动）应自动捕获，用户只需专注于内容创作。
3.  **数据融合而非干扰 (Integration over Interruption):** 时间轴和活动轴是内容的“伴侣”，而非“主角”。UI 设计应优雅、直观，通过视觉引导增强叙事，而非分散注意力。
4.  **为未来扩展而设计 (Built for Scale):** 数据模型和渲染逻辑必须解耦，以便未来轻松接入任何来源的数据（移动端、IoT设备、API等）。

## 2. 技术栈选型

*   **编辑器内核:** **Slate.js** - 因其可完全自定义的 JSON 数据模型，是实现非传统、高度结构化文档的最佳选择。
*   **前端框架:** **React** (或 Vue) - 与 Slate.js 深度集成，便于组件化开发。
*   **UI/样式:** **TailwindCSS** - 用于快速构建原子化的、高度可定制的 UI。
*   **状态管理 (可选):** Zustand / Redux - 用于管理非编辑器状态，如应用监听服务的状态。
*   **桌面端应用监听:** 使用 **Node.js** 的原生模块或系统级 API 库（如 `active-win` for Node.js）来捕获当前活跃窗口的应用信息。

## 3. 核心数据模型 (The Single Source of Truth)

这是整个系统的基石。我们将定义一个统一的、可扩展的 Slate.js 节点结构。

### 3.1. Slate 节点结构 (Schema)

编辑器内容由一个扁平的、只包含**块级元素 (Block Elements)** 的数组构成。不允许行内嵌套。

```typescript
// 类型定义 (TypeScript)

// 基础文本单元
type ParagraphElement = {
  type: 'paragraph';
  children: CustomText[];
};

// 我们的核心：情境标记块
type ContextMarkerElement = {
  type: 'context-marker';
  timestamp: ISODateTimeString; // ISO 8601 格式, e.g., "2025-11-03T10:30:00Z"
  activities: ActivitySpan[]; // 该时间点后的活动记录
  children: [{ text: '' }]; // Slate Void 节点的要求
};

// 单个活动片段
type ActivitySpan = {
  appId: string; // e.g., "com.figma.desktop", "com.apple.Music"
  appName: string; // e.g., "Figma", "Apple Music"
  appColor: HexColor; // App 主色调，用于渲染
  title: string | null; // 窗口标题，e.g., "一个UI设计稿.fig", "Song Name - Artist"
  duration: number; // 持续时长（秒）
};

// 编辑器顶层节点类型
type EditorElement = ParagraphElement | ContextMarkerElement;
```

### 3.2. 数据结构示例

```json
[
  {
    "type": "context-marker",
    "timestamp": "2025-11-03T10:00:00Z",
    "activities": [
      { "appId": "com.google.Chrome", "appName": "Chrome", "appColor": "#4285F4", "title": "Slate.js Docs", "duration": 300 }
    ],
    "children": [{ "text": "" }]
  },
  {
    "type": "paragraph",
    "children": [{ "text": "开始研究 Slate.js 的数据模型。" }]
  },
  {
    "type": "paragraph",
    "children": [{ "text": "它的灵活性非常适合我们的项目。" }]
  },
  {
    "type": "context-marker",
    "timestamp": "2025-11-03T10:05:30Z",
    "activities": [
      { "appId": "com.spotify.client", "appName": "Spotify", "appColor": "#1DB954", "title": "Lofi Beats", "duration": 180 },
      { "appId": "com.microsoft.VSCode", "appName": "VS Code", "appColor": "#007ACC", "title": "spec.md", "duration": 420 }
    ],
    "children": [{ "text": "" }]
  },
  {
    "type": "paragraph",
    "children": [{ "text": "切换了音乐，开始写规格文档。" }]
  }
]
```

## 4. 核心逻辑实现

### 4.1. 自动 `ContextMarker` 注入逻辑

这是编辑器的“智能”所在。

1.  **监听 `editor.onChange` 事件**: 每当编辑器内容发生变化时触发。
2.  **维护最后修改时间**: 在编辑器外部状态中，记录一个 `lastModifiedTimestamp`。
3.  **判断插入时机**:
    *   在 `onChange` 事件中，获取当前时间 `now`。
    *   如果 `now - lastModifiedTimestamp > 5 minutes` **且** 本次操作是用户输入文本（而非删除或格式化）。
    *   则在当前光标位置的段落**上方**插入一个新的 `ContextMarkerElement`。
4.  **获取情境数据**:
    *   调用 `ActivityService.getActivitiesSince(lastModifiedTimestamp)` 获取这5分钟内的活动数据。
    *   将获取到的 `activities` 数组填充到新的 `ContextMarkerElement` 中。
5.  **执行插入**:
    *   使用 `Transforms.insertNodes(editor, newContextMarker, { at: location })` 执行插入操作。
    *   确保光标位置正确恢复。
6.  **更新时间戳**: 无论是否插入，都将 `lastModifiedTimestamp` 更新为 `now`。

### 4.2. `ActivityService` - 活动监听服务

这是一个独立的、可插拔的服务，负责从各种来源收集活动数据。

*   **桌面端实现 (`DesktopActivityService`)**:
    *   使用 `setInterval` 每秒轮询一次。
    *   调用 `active-win()` 获取当前活跃的应用信息 (`name`, `owner.name`, `title`)。
    *   维护一个内部的 `activityLog` 数组，记录每个 App 的启动时间和结束时间。
    *   提供接口 `getActivitiesSince(timestamp)`，用于将原始 log 处理成 `ActivitySpan[]` 格式。

*   **移动端融合 (未来)**:
    *   移动端 App 会将自己的活动数据（通过原生 API 获取）发送到后端。
    *   `ActivityService` 将增加一个 `RemoteActivityProvider`，从后端 API 拉取属于该用户的移动端活动数据。
    *   最终 `getActivitiesSince` 会合并来自桌面端和所有远程提供者的数据，按时间排序后返回。

## 5. 渲染与 UI

### 5.1. Slate 自定义渲染器 (`renderElement`)

这是将数据模型变为可视化界面的核心。

```jsx
// React 组件伪代码
const renderElement = ({ element, attributes, children }) => {
  switch (element.type) {
    case 'paragraph':
      // 渲染段落，与左侧的时间轴对齐，留出轴的宽度
      return <p {...attributes} className="pl-16">{children}</p>;

    case 'context-marker':
      // 渲染一个容器，它将同时包含时间戳和活动轴
      return (
        <div {...attributes} className="relative h-auto">
          {/* 时间戳，绝对定位于容器左侧 */}
          <div className="absolute left-0 top-0 text-gray-500 text-xs w-14 text-right pr-2">
            {formatTime(element.timestamp)}
          </div>

          {/* 活动轴，在时间戳下方渲染 */}
          <div className="absolute left-0 top-6 w-14 flex flex-col items-end">
            {renderActivityAxis(element.activities)}
          </div>
          {children} {/* Slate 要求必须渲染 children */}
        </div>
      );
    default:
      return <p {...attributes}>{children}</p>;
  }
};
```

### 5.2. 活动轴渲染 (`renderActivityAxis`)

这个函数负责将 `ActivitySpan[]` 数组渲染成视觉化的轴线。

*   **输入**: `ActivitySpan[]`
*   **逻辑**:
    1.  遍历 `activities` 数组。
    2.  对于每个 `activity`，创建一个 `<div>`。
    3.  **核心视觉**: `height` 属性与 `activity.duration` 成正比（需要一个缩放因子，`height = duration * 0.1`）。
    4.  `backgroundColor` 设置为 `activity.appColor`。
    5.  添加 `title` 属性或Tooltip，鼠标悬浮时显示应用名和窗口标题。
    6.  **"Breakout"/压缩逻辑**:
        *   在 `ActivityService` 或渲染时进行预处理。
        *   如果一段 `activities` 的总时长很长，但中间没有对应的 `paragraph` 节点，则判定为“无记录时段”。
        *   对此类时段，渲染方式变为：
            *   **方案A (虚线):** 渲染一条固定高度的虚线或波浪线。
            *   **方案B (Icon堆叠):** 不渲染轴线，只显示几个关键的 App Icon 堆叠在一起，表示“这段时间主要在用这几个应用”。
        *   这需要在数据模型中增加一个标志位，如 `activity.isCompressed = true`。

## 6. 结论与下一步

这份文档定义了一个高度可扩展的情境编辑器架构。**下一步，开发团队（或 Copilot）可以**:

1.  **搭建 Slate.js 基础环境**，并实现 `ParagraphElement` 的基本编辑。
2.  **开发独立的 `DesktopActivityService`**，在后台打印出捕获到的活动数据。
3.  **实现 `ContextMarker` 注入逻辑**，在编辑器中自动插入带有真实活动数据的标记节点。
4.  **编写 `renderElement` 组件**，将数据模型可视化，精调 CSS 以达到理想的视觉效果。
5.  **实现“Breakout”压缩显示逻辑**，优化长时间无记录片段的显示。

该方案将确保产品在初期能快速实现核心功能，同时为未来接入更多、更复杂的数据源（移动端、音乐服务 API、日历 API 等）打下了坚实、可扩展的基础。

