
# 多语言上下文感知日期/时间段解析器 - 设计与实现文档 (最终版)

## 1. 方案总览

### 1.1. 目标

构建一个支持**中/英双语**、**上下文感知**、**纯本地**、**高性能**的自然语言日期/时间段解析器。该方案旨在提供零延迟、完全离线、且高度智能的日期输入体验。

### 1.2. 核心设计思想

采用**分层规则**、**三层上下文**、**柔性日期**与**别名系统**相结合的四维模型。

*   **分层规则**:
    1.  **精确时间段 (`fuzzyPeriodRules`)**: 匹配“下午”、“morning”等。
    2.  **柔性日期 (`fuzzyDateRangeRules`)**: 匹配“下周”、“next month”等规划窗口。
    3.  **精确时间点 (`fuzzyRules`)**: 匹配“大后天”、“eom” (end of month) 等。
    4.  **`chrono-node` 兜底**: 处理标准格式。

*   **三层上下文**:
    1.  **父事件上下文**: 基于嵌套事件的开始/结束日期。
    2.  **活动视图上下文**: 基于用户当前查看的日历视图。
    3.  **全局默认上下文**: 基于当前日期。

*   **柔性日期**: 将“下周”等词汇解析为时间窗口（如：周一至周日），并在UI上进行特殊展示，以区别于精确日期。

*   **别名系统 (Aliasing)**: 通过将大量近义词和缩写映射到少数“核心词汇”，以极低的成本实现了对多样化输入的覆盖，解决了枚举不全的问题。

## 2. 核心模块代码实现

### 2.1. 模块一：日期辅助函数 (`dateHelpers.js`)

*(此模块与V2版相同，提供日期计算的原子能力，此处为简洁省略其代码)*

### 2.2. 模块二：别名与规则字典

这是系统的核心，我们将别名定义和规则函数整合在一起，以实现逻辑复用。

```javascript
// file: fuzzyRulesEngine.js (整合了所有规则和别名)
import { /* ... all functions from dateHelpers.js ... */ } from './dateHelpers';

// =======================================================
// 1. 精确时间点规则 (Point in Time)
// =======================================================
const fuzzyRules = {
  // --- 核心词汇定义 ---
  '大后天': (refDate) => addDays(refDate, 3),
  '大前天': (refDate) => addDays(refDate, -3),
  '月底': (refDate) => getEndOfMonth(refDate),
  '月初': (refDate) => getStartOfMonth(refDate),
  '年底': (refDate) => getEndOfYear(refDate),
  '年初': (refDate) => getStartOfYear(refDate),
  '明年': (refDate) => getStartOfYear(new Date(refDate.getFullYear() + 1, 0, 1)),
  '后年': (refDate) => getStartOfYear(new Date(refDate.getFullYear() + 2, 0, 1)),
  '去年': (refDate) => getStartOfYear(new Date(refDate.getFullYear() - 1, 0, 1)),
  '周报日': (refDate) => getThisFriday(refDate),
  '下周一': (refDate) => getNextMonday(refDate),
  '季末': (refDate) => getEndOfQuarter(refDate),
  'ddl': (refDate) => getEndOfDay(refDate),
  // ... 其他精确时间点核心词汇 ...
  // --- 上下文感知规则 ---
  '出发当天': (refDate, context) => context.parentEventStart || getStartOfDay(refDate),
  '落地后一天': (refDate, context) => addDays(context.parentEventStart || refDate, 1),
  '返程日': (refDate, context) => context.parentEventEnd || getStartOfDay(refDate),
  '返程前一天': (refDate, context) => addDays(context.parentEventEnd || refDate, -1),
};

// --- 别名映射 ---
const fuzzyRuleAliases = {
  '3 days later': '大后天', 'in 3 days': '大后天',
  '3 days ago': '大前天',
  'end of month': '月底', 'eom': '月底', '月末': '月底',
  'start of month': '月初', 'som': '月初',
  'end of year': '年底', 'eoy': '年底',
  'start of year': '年初', 'soy': '年初',
next_year: '明年', 'ny': '明年',
  'year after next': '后年',
last_year: '去年',
  'weekly report': '周报日', '周报': '周报日',
  'next monday': '下周一', 'next mon': '下周一',
  'end of quarter': '季末', 'eoq': '季末', '季度末': '季末',
  'deadline': 'ddl', 'due': 'ddl', 'due date': 'ddl', '死线': 'ddl', '截止日期': 'ddl',
  'departure date': '出发当天', '出发日': '出发当天',
  'day after landing': '落地后一天', '落地第二天': '落地后一天',
  'return date': '返程日', '归期': '返程日',
  'day before return': '返程前一天',
};

// =======================================================
// 2. 柔性日期规则 (Flexible Date Ranges)
// =======================================================
const fuzzyDateRangeRules = {
  // --- 核心词汇定义 ---
  '下周': (refDate) => ({ startDate: getNextMonday(refDate), endDate: getThisSunday(getNextMonday(refDate)) }),
  '本周': (refDate) => {
    const day = refDate.getDay();
    const diff = day === 0 ? -6 : 1 - day;
    const monday = getStartOfDay(addDays(refDate, diff));
    return { startDate: monday, endDate: getThisSunday(monday) };
  },
  '周末': (refDate) => {
    const day = refDate.getDay();
    const diff = (day === 6 || day === 0) ? 0 : 6 - day;
    const saturday = getStartOfDay(addDays(refDate, diff));
    return { startDate: saturday, endDate: getEndOfDay(addDays(saturday, 1)) };
  },
  '三天内': (refDate) => ({ startDate: getStartOfDay(refDate), endDate: getEndOfDay(addDays(refDate, 2)) }),
  '下个月': (refDate) => {
    const start = getStartOfMonth(addDays(getEndOfMonth(refDate), 1));
    return { startDate: start, endDate: getEndOfMonth(start) };
  },
  '本月': (refDate) => ({ startDate: getStartOfMonth(refDate), endDate: getEndOfMonth(refDate) }),
};

// --- 别名映射 ---
const fuzzyDateRangeAliases = {
  'next week': '下周', 'nxt wk': '下周',
  'this week': '本周', 'current week': '本周',
  'weekend': '周末', 'this weekend': '周末',
  'in 3 days': '三天内', 'within 3 days': '三天内',
  'next month': '下个月',
  'this month': '本月', 'current month': '本月',
};


// =======================================================
// 3. 精确时间段规则 (Precise Periods)
// =======================================================
const fuzzyPeriodRules = {
  // --- 核心词汇定义 ---
  '上午': (refDate) => ({ startDate: setTime(refDate, 9), endDate: setTime(refDate, 12) }),
  '下午': (refDate) => ({ startDate: setTime(refDate, 14), endDate: setTime(refDate, 18) }),
  '晚上': (refDate) => ({ startDate: setTime(refDate, 19), endDate: setTime(refDate, 23) }),
  '午休': (refDate) => ({ startDate: setTime(refDate, 12), endDate: setTime(refDate, 13, 30) }),
  '上班时间': (refDate) => ({ startDate: setTime(refDate, 9), endDate: setTime(refDate, 18) }),
  '晨会': (refDate) => ({ startDate: setTime(refDate, 10), endDate: setTime(refDate, 10, 15) }),
};

// --- 别名映射 ---
const fuzzyPeriodAliases = {
  'morning': '上午', 'am': '上午', '早上': '上午',
  'afternoon': '下午', 'pm': '下午',
  'evening': '晚上', 'night': '晚上', '今晚': '晚上',
  'lunch break': '午休',
  'work hours': '上班时间', 'office hours': '上班时间', '工作时间': '上班时间',
  'stand-up': '晨会', 'daily scrum': '晨会', '站会': '晨会',
};

// =======================================================
// 导出所有规则和别名
// =======================================================
export const rules = {
    point: { funcs: fuzzyRules, aliases: fuzzyRuleAliases },
    range: { funcs: fuzzyDateRangeRules, aliases: fuzzyDateRangeAliases },
    period: { funcs: fuzzyPeriodRules, aliases: fuzzyPeriodAliases },
};

```

### 2.3. 主解析器实现 (`intelligentParser.js`)

解析器现在需要先通过别名系统找到对应的核心函数，再执行它。

```javascript
// file: intelligentParser.js (最终版)
import * as chrono from 'chrono-node';
import { rules } from './fuzzyRulesEngine';
import { formatAsChronoResult, formatAsPeriodResult } from './dateHelpers';

// 反向别名映射，用于快速查找
const reversedAliases = {
    point: Object.fromEntries(Object.entries(rules.point.aliases).map(a => a.reverse())),
    range: Object.fromEntries(Object.entries(rules.range.aliases).map(a => a.reverse())),
    period: Object.fromEntries(Object.entries(rules.period.aliases).map(a => a.reverse())),
};

// 辅助函数，用于解析别名
function getCoreFunction(text) {
    const categories = ['period', 'range', 'point'];
    for (const category of categories) {
        const funcs = rules[category].funcs;
        const aliases = rules[category].aliases;
        // 1. 直接匹配核心词汇
        if (funcs[text]) return { func: funcs[text], type: category };
        // 2. 匹配别名
        const coreTerm = aliases[text];
        if (coreTerm && funcs[coreTerm]) {
            return { func: funcs[coreTerm], type: category };
        }
    }
    return { func: null, type: null };
}

export function parseIntelligently(text, context = {}) {
    const trimmedText = text.trim().toLowerCase();
    const refDate = context.activeViewDate || new Date();
    
    const { func, type } = getCoreFunction(trimmedText);

    if (func) {
        if (type === 'point') {
            const date = func(refDate, context);
            return formatAsChronoResult(date, text, refDate);
        }
        if (type === 'range' || type === 'period') {
            const { startDate, endDate } = func(refDate, context);
            const result = formatAsPeriodResult(startDate, endDate, text, refDate);
            result.periodType = (type === 'range') ? 'flexible' : 'precise';
            return result;
        }
    }

    // --- Chrono 兜底 ---
    const chronoResult = chrono.parse(trimmedText, refDate, { forwardDate: true });
    if (chronoResult && chronoResult.length > 0) {
        if (chronoResult[0].end) {
            chronoResult[0].periodType = 'precise'; // chrono的结果视为精确时间段
        }
        return chronoResult[0];
    }

    return null;
}
```

## 3. 测试方案 (已升级)

### 3.1. 开发者测试方案

测试用例需要覆盖别名系统。

```javascript
// file: intelligentParser.test.js (追加别名测试)

describe('Parser - Alias System', () => {
    const TODAY = new Date('2025-11-03T10:00:00Z');

    it('should parse English alias "eom" to the same as Chinese "月底"', () => {
        const resultEom = parseIntelligently('eom', { activeViewDate: TODAY });
        const resultYuedi = parseIntelligently('月底', { activeViewDate: TODAY });
        expect(resultEom.start.date().toISOString()).toBe(resultYuedi.start.date().toISOString());
        expect(resultEom.start.date().getDate()).toBe(30); // Nov 2025 has 30 days
    });

    it('should parse English abbreviation "nxt wk" as a flexible period', () => {
        const result = parseIntelligently('nxt wk', { activeViewDate: TODAY });
        expect(result.periodType).toBe('flexible');
        expect(result.start.date().toISOString().startsWith('2025-11-10')).toBe(true);
    });

    it('should parse English alias "stand-up" to the same as Chinese "晨会"', () => {
        const resultStandUp = parseIntelligently('stand-up', { activeViewDate: TODAY });
        const resultChenhui = parseIntelligently('晨会', { activeViewDate: TODAY });
        expect(resultStandUp.periodType).toBe('precise');
        expect(resultStandUp.start.date().toISOString()).toBe(resultChenhui.start.date().toISOString());
    });
});
```

### 3.2. 产品经理/QA 测试方案

| **场景分类**     | **测试用例**                                                                                                                              | **操作步骤**                                                                                                     | **预期结果**                                                                                                                                       |
| ---------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| **多语言-别名**  | 输入 `eom`、`end of month` 和 `月底`                                                                                                       | 分别在输入框输入这三个词。                                                                                         | 三次解析结果应完全相同，都指向当月的最后一天。                                                                                                     |
| **多语言-缩写**  | 输入 `nxt wk`                                                                                                                             | 在输入框输入 `nxt wk`。                                                                                            | 解析结果应与输入 `next week` 或 `下周` 完全相同，即一个“柔性日期”窗口，UI上显示为“下周”或"Next Week"。                                            |
| **近义词覆盖**   | 输入 `due date`                                                                                                                           | 在输入框输入 `due date`。                                                                                          | 解析结果应与输入 `ddl` 或 `死线` 相同，都指向当天的结束时间。                                                                                       |
| **组合测试**     | 在父事件（12.8-12.12）下，输入 `day after landing`                                                                                        | 1. 创建出差事件。<br>2. 在子任务中输入 `day after landing`。                                                          | 解析结果应为 `2025-12-09`，证明别名系统与上下文感知能力可以协同工作。                                                                               |

