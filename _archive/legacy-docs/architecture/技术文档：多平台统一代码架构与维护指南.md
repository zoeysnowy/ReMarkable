
# **多平台统一代码架构与维护指南 v1.0**

## 1. 宗旨与目标

本指南旨在为 `ReMarkable` 项目定义一套清晰、可扩展、易于维护的多平台（Windows, macOS, Android, iOS, Web）代码架构。我们的目标不是构建多个孤立的应用，而是创建一个统一的、共享的**代码生态系统**。

**核心目标：**

1.  **最大化代码复用 (Maximize Reuse):** 核心业务逻辑、UI组件和应用状态管理应**编写一次，全平台通用**。
2.  **最小化维护成本 (Minimize Maintenance):** 修复 Bug 或添加功能应在一个地方完成，并自动同步到所有平台。
3.  **保障平台一致性 (Ensure Consistency):** 确保所有平台的用户体验和业务逻辑保持高度一致。
4.  **赋能高效开发 (Enable Velocity):** 清晰的结构和自动化工具链能让新成员快速上手，并加速新功能的开发周期。
5.  **拥抱原生能力 (Embrace Native Power):** 在实现高复用性的同时，保留深入调用各平台原生功能的能力。

## 2. 核心架构决策：Monorepo

我们将采用 **Monorepo (单一代码仓库)** 作为管理所有平台代码的唯一策略。此策略将所有项目（应用、库、共享包）都存放在同一个 Git 仓库中。

**技术选型：**

*   **仓库管理:** Git
*   **依赖管理:** **pnpm** - 利用其符号链接机制，高效管理工作区内的共享依赖，避免依赖项重复安装。
*   **任务编排与构建:** **Turborepo** - 提供高性能的构建缓存（本地和远程）和智能的任务调度，极大提升构建和测试速度。

## 3. Monorepo 目录结构规范

这是我们代码生态系统的物理蓝图。清晰的目录结构是实现代码分离与复用的基础。

```plaintext
/remarkable-monorepo/
|
|-- package.json             # 根配置，定义 pnpm 工作区 (workspaces)
|-- pnpm-workspace.yaml      # pnpm 工作区配置文件
|-- turbo.json               # Turborepo 任务流与缓存配置
|
|-- /apps/                   # 最终产品应用 (Consumers)
|   |-- /web/                # Next.js Web 应用
|   |-- /desktop/            # Electron 桌面应用 (Win/Mac)
|   |-- /mobile/             # React Native 移动应用 (iOS/Android)
|
|-- /packages/               # 可复用共享包 (Providers)
|   |
|   |-- /editor-core/        # Slate.js 编辑器核心 (平台无关)
|   |-- /ui/                 # 共享 UI 组件库 (平台感知)
|   |-- /design-system/      # 设计规范 (Tokens, Tailwind配置)
|   |-- /app-logic/          # 共享业务逻辑与状态管理 (平台无关)
|   |-- /native-bindings/    # 原生功能统一接口 (平台特定实现)
```

## 4. 共享策略详解 (`/packages`)

`/packages` 目录是实现代码复用的心脏。每个子目录都是一个独立的、内部的 npm 包。

#### 4.1. `@remarkable/editor-core` - **编辑器核心**
*   **复用率:** 100%
*   **职责:** 封装所有与 Slate.js 相关的逻辑，包括 Schema 定义、插件、自定义元素渲染器、命令和查询。它是产品的“皇冠明珠”。
*   **维护:** 任何对编辑器行为的修改都应在此包内完成。

#### 4.2. `@remarkable/ui` - **UI 组件库**
*   **复用率:** ~90%
*   **职责:** 提供跨平台的 UI 组件（如 Button, Modal, Card）。
*   **实现:** 采用**平台特定文件后缀**策略 (`.web.tsx`, `.native.tsx`)。上层应用只需 `import { Button }`，构建工具会自动解析到对应平台的文件。共享的逻辑和类型则放在 `Button.tsx` 中。

#### 4.3. `@remarkable/design-system` - **设计系统**
*   **复用率:** 100%
*   **职责:** 定义设计语言。包含共享的 `tailwind.config.js`，颜色、字体、间距等设计令牌 (Design Tokens)。所有应用和 `ui` 包都应消费此配置，以保证视觉统一。

#### 4.4. `@remarkable/app-logic` - **应用逻辑**
*   **复用率:** 100%
*   **职责:** 存放所有与 UI 无关的纯 JavaScript/TypeScript 逻辑。例如：API 客户端、全局状态管理 (Zustand/Redux store)、工具函数、`ActivityService` 的数据处理部分等。

#### 4.5. `@remarkable/native-bindings` - **原生桥接**
*   **复用率:** 接口 100%, 实现 0%
*   **职责:** 这是优雅处理平台差异的关键。它定义一个统一的 JS 接口（如 `activityMonitor.start()`)，内部则根据当前运行环境（Electron, React Native）加载不同的实现。这遵循了“依赖倒置原则”，使上层业务逻辑与底层平台实现完全解耦。

## 5. 应用层职责 (`/apps`)

`/apps` 中的应用应该是“轻量级”的组装层。

*   **职责:**
    1.  **平台初始化:** 配置 Electron 的 `BrowserWindow`，或 React Native 的根组件。
    2.  **依赖组装:** 从 `/packages` 目录中引入共享包，并将它们组合成完整的应用界面和逻辑。
    3.  **原生实现:** 编写特定于平台的原生代码（如 Android 的应用监听服务），并通过 `@remarkable/native-bindings` 包中定义的接口暴露给共享层。

## 6. 开发与维护工作流

1.  **分支策略:** 采用标准的 Git Flow 或 GitHub Flow。所有开发都在功能分支上进行。

2.  **依赖管理:**
    *   安装新依赖时，使用 `pnpm add <package-name> --filter <workspace-name>` 将其精确地添加到指定的包中。
    *   严禁在 `apps` 中安装本应在 `packages` 中共享的依赖。

3.  **构建与测试:**
    *   在根目录运行 `turbo run build` 来构建整个项目。Turborepo 会自动处理任务依赖并利用缓存。
    *   在根目录运行 `turbo run test` 来运行所有测试。

4.  **代码规范:**
    *   整个 Monorepo 使用统一的 Prettier 和 ESLint 配置，确保代码风格一致。
    *   配置文件（`.eslintrc.js`, `prettier.config.js`）应放在仓库根目录。

5.  **版本控制与发布:**
    *   当共享包 (`/packages`) 发生变更时，应使用自动化工具（如 [Changesets](https://github.com/changesets/changesets)）来管理版本号、生成变更日志 (Changelog)，并发布到私有 npm registry（如果需要）。

## 7. 结论

此 Monorepo 架构将我们的项目从一系列独立的仓库转变为一个内聚的、可扩展的生态系统。通过严格遵守此架构指南，我们将在项目的整个生命周期内获得巨大的回报：更高的开发效率、更低的维护成本、更强的产品一致性。

这是保障我们长期成功的技术战略基石。

